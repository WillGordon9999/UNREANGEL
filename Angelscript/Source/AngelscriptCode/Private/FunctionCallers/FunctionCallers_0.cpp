//#pragma once
//#include "FunctionCallers.h"
//#include "Components/PrimitiveComponent.h"
//#include "InterchangeFactoryBase.h"
//#include "Elements/Framework/TypedElementSelectionSet.h"
//#include "Elements/Framework/TypedElementRegistry.h"
//#include "HudSettings.h"
//#include "GameSessionSettings.h"
//#include "GameNetworkManagerSettings.h"
//#include "GameMapsSettings.h"
//#include "MeshDescriptionBase.h"
//#include "StaticMeshDescription.h"
//#include "ClothingSimulationInteractor.h"
//#include "ToolMenu.h"
//#include "ToolMenus.h"
//#include "ToolMenuEntryScript.h"
//#include "ClassGenerator/ASClass.h"

/*
FFuncEntry Entries[]
{
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, GetIgnoredComponents, (), ERASE_ARGUMENT_PACK(TArray<uint32>)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, GetIgnoredActors, (), ERASE_ARGUMENT_PACK(TArray<uint32>)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, ClearIgnoredComponents, (), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, ClearIgnoredActors, (), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, SetNumIgnoredComponents, (int), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredActor, (const AActor*), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredActor, (const uint), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredActors, (const TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredActors, (const TArray<const AActor*>&), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredComponent, (const UPrimitiveComponent*), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredComponents, (const TArray<UPrimitiveComponent*>&), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, AddIgnoredComponent_LikelyDuplicatedRoot, (const UPrimitiveComponent*), ERASE_ARGUMENT_PACK(void)) },
	//{ ERASE_METHOD_PTR(FCollisionQueryParams, ToString, (), ERASE_ARGUMENT_PACK(FString)) },



//{ ERASE_METHOD_PTR(UObject, AddToRoot, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, RemoveFromRoot, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, GetIsRooted, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, IsTransient, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, Modify, (bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, SetTransactional, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, IsSupportedForNetworking, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, GetClass, (), ERASE_ARGUMENT_PACK(UClass*)) },
//{ ERASE_METHOD_PTR(UObject, GetOuter, (), ERASE_ARGUMENT_PACK(UObject*)) },
//{ ERASE_METHOD_PTR(UObject, GetTypedOuter, (const TSubclassOf<UObject>&), ERASE_ARGUMENT_PACK(UObject*)) },
//{ ERASE_METHOD_PTR(UObject, GetOutermost, (), ERASE_ARGUMENT_PACK(UPackage*)) },
//{ ERASE_METHOD_PTR(UObject, GetPackage, (), ERASE_ARGUMENT_PACK(UPackage*)) },
//{ ERASE_METHOD_PTR(UObject, MarkPackageDirty, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, GetWorld, (), ERASE_ARGUMENT_PACK(UWorld*)) },
//{ ERASE_METHOD_PTR(UObject, GetName, (), ERASE_ARGUMENT_PACK(FName)) },
//{ ERASE_METHOD_PTR(UObject, GetFullName, (const UObject*), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(UObject, GetPathName, (const UObject*), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(UObject, IsA, (const UClass*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UObject, SaveConfig, (uint64, const TCHAR*, FConfigCacheIni*, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, LoadConfig, (UClass*, const TCHAR*, uint32, FProperty*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, ReloadConfig, (UClass*, const TCHAR*, uint32, FProperty*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, CopyScriptPropertiesFrom, (const UObject*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, opCast, (?&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UObject, ToString, (), ERASE_ARGUMENT_PACK(FString)) },


//{ ERASE_METHOD_PTR(UPackage, IsDirty, (), ERASE_ARGUMENT_PACK(bool)) },


//{ ERASE_METHOD_PTR(UClass, GetDefaultObject, (), ERASE_ARGUMENT_PACK(UObject*)) },
//{ ERASE_METHOD_PTR(UClass, IsChildOf, (UClass*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UClass, IsAbstract, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UClass, GetSuperClass, (), ERASE_ARGUMENT_PACK(UClass*)) },


//{ ERASE_METHOD_PTR(UEnum, GetNameByIndex, (int), ERASE_ARGUMENT_PACK(FName)) },
//{ ERASE_METHOD_PTR(UEnum, GetIndexByName, (FName, EGetByNameFlags), ERASE_ARGUMENT_PACK(int)) },
//{ ERASE_METHOD_PTR(UEnum, GetNameByValue, (int64), ERASE_ARGUMENT_PACK(FName)) },
//{ ERASE_METHOD_PTR(UEnum, GetValueByName, (FName, EGetByNameFlags), ERASE_ARGUMENT_PACK(int64)) },
//{ ERASE_METHOD_PTR(UEnum, GetNameStringByIndex, (int), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(UEnum, GetIndexByNameString, (const FString&, EGetByNameFlags), ERASE_ARGUMENT_PACK(int)) },
//{ ERASE_METHOD_PTR(UEnum, GetNameStringByValue, (int64), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(UEnum, GetValueByNameString, (const FString&, EGetByNameFlags), ERASE_ARGUMENT_PACK(int64)) },
//{ ERASE_METHOD_PTR(UEnum, GetDisplayNameTextByIndex, (int), ERASE_ARGUMENT_PACK(FText)) },
//{ ERASE_METHOD_PTR(UEnum, GetDisplayNameTextByValue, (int64), ERASE_ARGUMENT_PACK(FText)) },
//{ ERASE_METHOD_PTR(UEnum, GetMaxEnumValue, (), ERASE_ARGUMENT_PACK(int64)) },
//{ ERASE_METHOD_PTR(UEnum, NumEnums, (), ERASE_ARGUMENT_PACK(int)) },
//{ ERASE_METHOD_PTR(UEnum, IsValidEnumValue, (int64), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UEnum, IsValidEnumName, (FName), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UEnum, ContainsExistingMax, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UEnum, GenerateEnumPrefix, (), ERASE_ARGUMENT_PACK(FString)) },


{ ERASE_METHOD_PTR(UTypedElementRegistry, GetElementInterface, (const FScriptTypedElementHandle&, const TSubclassOf<UInterface>)const, ERASE_ARGUMENT_PACK(UObject*)) },


{ ERASE_METHOD_PTR(UTypedElementSelectionSet, AllowSelectionModifiers, (const FScriptTypedElementHandle&)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, CanDeselectElement, (const FScriptTypedElementHandle&, const FTypedElementSelectionOptions)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, CanSelectElement, (const FScriptTypedElementHandle&, const FTypedElementSelectionOptions)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, ClearSelection, (const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, CountSelectedElements, (const TSubclassOf<UInterface>)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, CountSelectedObjects, (const UClass*)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, DeselectElement, (const FScriptTypedElementHandle&, const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, DeselectElements, (const TArray<FScriptTypedElementHandle>&, const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetBottomSelectedObject, (const UClass*)const, ERASE_ARGUMENT_PACK(UObject*)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetCurrentSelectionState, ()const, ERASE_ARGUMENT_PACK(FTypedElementSelectionSetState)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetNumSelectedElements, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetSelectedObjects, (const UClass*)const, ERASE_ARGUMENT_PACK(TArray<UObject*>)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetSelectionElement, (const FScriptTypedElementHandle&, const ETypedElementSelectionMethod)const, ERASE_ARGUMENT_PACK(FScriptTypedElementHandle)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetTopSelectedObject, (const UClass*)const, ERASE_ARGUMENT_PACK(UObject*)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, HasSelectedElements, (const TSubclassOf<UInterface>)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, HasSelectedObjects, (const UClass*)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, IsElementSelected, (const FScriptTypedElementHandle&, const FTypedElementIsSelectedOptions)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, GetSelectedElementHandles, (const TSubclassOf<UInterface>)const, ERASE_ARGUMENT_PACK(TArray<FScriptTypedElementHandle>)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, RestoreSelectionState, (const FTypedElementSelectionSetState&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, SelectElement, (const FScriptTypedElementHandle&, const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, SelectElements, (const TArray<FScriptTypedElementHandle>&, const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UTypedElementSelectionSet, SetSelection, (const TArray<FScriptTypedElementHandle>&, const FTypedElementSelectionOptions), ERASE_ARGUMENT_PACK(bool)) },


//{ ERASE_METHOD_PTR(UCookerSettings, SetbAllowASTCHDRProfile, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UCookerSettings, SetbAllowCookedDataInEditorBuilds, (bool), ERASE_ARGUMENT_PACK(void)) },


//{ ERASE_METHOD_PTR(UGameMapsSettings, GetSkipAssigningGamepadToPlayer1, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UGameMapsSettings, SetSkipAssigningGamepadToPlayer1, (bool), ERASE_ARGUMENT_PACK(void)) },


//{ ERASE_METHOD_PTR(UGameNetworkManagerSettings, SetbIsStandbyCheckingEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },


//{ ERASE_METHOD_PTR(UGameSessionSettings, SetbRequiresPushToTalk, (bool), ERASE_ARGUMENT_PACK(void)) },


//{ ERASE_METHOD_PTR(UHudSettings, SetbShowHUD, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UMeshDescriptionBase, ComputePolygonTriangulation, (FPolygonID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateEdge, (FVertexID, FVertexID), ERASE_ARGUMENT_PACK(FEdgeID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateEdgeWithID, (FEdgeID, FVertexID, FVertexID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreatePolygon, (FPolygonGroupID, TArray<FVertexInstanceID>&, TArray<FEdgeID>&), ERASE_ARGUMENT_PACK(FPolygonID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreatePolygonGroup, (), ERASE_ARGUMENT_PACK(FPolygonGroupID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreatePolygonGroupWithID, (FPolygonGroupID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreatePolygonWithID, (FPolygonID, FPolygonGroupID, TArray<FVertexInstanceID>&, TArray<FEdgeID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateTriangle, (FPolygonGroupID, const TArray<FVertexInstanceID>&, TArray<FEdgeID>&), ERASE_ARGUMENT_PACK(FTriangleID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateTriangleWithID, (FTriangleID, FPolygonGroupID, const TArray<FVertexInstanceID>&, TArray<FEdgeID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateVertex, (), ERASE_ARGUMENT_PACK(FVertexID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateVertexInstance, (FVertexID), ERASE_ARGUMENT_PACK(FVertexInstanceID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateVertexInstanceWithID, (FVertexInstanceID, FVertexID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, CreateVertexWithID, (FVertexID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeleteEdge, (FEdgeID, TArray<FVertexID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeletePolygon, (FPolygonID, TArray<FEdgeID>&, TArray<FVertexInstanceID>&, TArray<FPolygonGroupID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeletePolygonGroup, (FPolygonGroupID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeleteTriangle, (FTriangleID, TArray<FEdgeID>&, TArray<FVertexInstanceID>&, TArray<FPolygonGroupID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeleteVertex, (FVertexID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, DeleteVertexInstance, (FVertexInstanceID, TArray<FVertexID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, Empty, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetEdgeConnectedPolygons, (FEdgeID, TArray<FPolygonID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetEdgeConnectedTriangles, (FEdgeID, TArray<FTriangleID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetEdgeCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetEdgeVertex, (FEdgeID, int)const, ERASE_ARGUMENT_PACK(FVertexID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetEdgeVertices, (const FEdgeID, TArray<FVertexID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumEdgeConnectedPolygons, (FEdgeID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumEdgeConnectedTriangles, (FEdgeID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumPolygonGroupPolygons, (FPolygonGroupID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumPolygonInternalEdges, (FPolygonID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumPolygonTriangles, (FPolygonID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumPolygonVertices, (FPolygonID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexConnectedEdges, (FVertexID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexConnectedPolygons, (FVertexID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexConnectedTriangles, (FVertexID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexInstanceConnectedPolygons, (FVertexInstanceID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexInstanceConnectedTriangles, (FVertexInstanceID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetNumVertexVertexInstances, (FVertexID)const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonAdjacentPolygons, (FPolygonID, TArray<FPolygonID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonGroupCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonGroupPolygons, (FPolygonGroupID, TArray<FPolygonID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonInternalEdges, (FPolygonID, TArray<FEdgeID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonPerimeterEdges, (FPolygonID, TArray<FEdgeID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonPolygonGroup, (FPolygonID)const, ERASE_ARGUMENT_PACK(FPolygonGroupID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonTriangles, (FPolygonID, TArray<FTriangleID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonVertexInstances, (FPolygonID, TArray<FVertexInstanceID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetPolygonVertices, (FPolygonID, TArray<FVertexID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleAdjacentTriangles, (FTriangleID, TArray<FTriangleID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleEdges, (FTriangleID, TArray<FEdgeID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTrianglePolygon, (FTriangleID)const, ERASE_ARGUMENT_PACK(FPolygonID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTrianglePolygonGroup, (FTriangleID)const, ERASE_ARGUMENT_PACK(FPolygonGroupID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleVertexInstance, (FTriangleID, int)const, ERASE_ARGUMENT_PACK(FVertexInstanceID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleVertexInstances, (FTriangleID, TArray<FVertexInstanceID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetTriangleVertices, (FTriangleID, TArray<FVertexID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexAdjacentVertices, (FVertexID, TArray<FVertexID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexConnectedEdges, (FVertexID, TArray<FEdgeID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexConnectedPolygons, (FVertexID, TArray<FPolygonID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexConnectedTriangles, (FVertexID, TArray<FTriangleID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceConnectedPolygons, (FVertexInstanceID, TArray<FPolygonID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceConnectedTriangles, (FVertexInstanceID, TArray<FTriangleID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceCount, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceForPolygonVertex, (FPolygonID, FVertexID)const, ERASE_ARGUMENT_PACK(FVertexInstanceID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceForTriangleVertex, (FTriangleID, FVertexID)const, ERASE_ARGUMENT_PACK(FVertexInstanceID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstancePairEdge, (FVertexInstanceID, FVertexInstanceID)const, ERASE_ARGUMENT_PACK(FEdgeID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexInstanceVertex, (FVertexInstanceID)const, ERASE_ARGUMENT_PACK(FVertexID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexPairEdge, (FVertexID, FVertexID)const, ERASE_ARGUMENT_PACK(FEdgeID)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexPosition, (FVertexID)const, ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, GetVertexVertexInstances, (FVertexID, TArray<FVertexInstanceID>&)const, ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsEdgeInternal, (FEdgeID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsEdgeInternalToPolygon, (FEdgeID, FPolygonID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsEdgeValid, (FEdgeID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsEmpty, ()const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsPolygonGroupValid, (FPolygonGroupID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsPolygonValid, (FPolygonID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsTrianglePartOfNgon, (FTriangleID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsTriangleValid, (const FTriangleID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsVertexInstanceValid, (FVertexInstanceID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsVertexOrphaned, (FVertexID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, IsVertexValid, (FVertexID)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewEdges, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewPolygonGroups, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewPolygons, (const int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewTriangles, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewVertexInstances, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReserveNewVertices, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, ReversePolygonFacing, (FPolygonID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, SetPolygonPolygonGroup, (FPolygonID, FPolygonGroupID), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, SetPolygonVertexInstances, (FPolygonID, const TArray<FVertexInstanceID>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshDescriptionBase, SetVertexPosition, (FVertexID, const FVector&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UStaticMeshDescription, CreateCube, (FVector, FVector, FPolygonGroupID, FPolygonID&, FPolygonID&, FPolygonID&, FPolygonID&, FPolygonID&, FPolygonID&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshDescription, GetVertexInstanceUV, (FVertexInstanceID, int)const, ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UStaticMeshDescription, SetPolygonGroupMaterialSlotName, (FPolygonGroupID, const FName&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshDescription, SetVertexInstanceUV, (FVertexInstanceID, FVector2D, int), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UClothingSimulationInteractor, ClothConfigUpdated, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, DisableGravityOverride, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, EnableGravityOverride, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetClothingInteractor, (const FString&)const, ERASE_ARGUMENT_PACK(UClothingInteractor*)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetNumCloths, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetNumDynamicParticles, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetNumIterations, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetNumKinematicParticles, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetNumSubsteps, ()const, ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, GetSimulationTime, ()const, ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, PhysicsAssetUpdated, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, SetAnimDriveSpringStiffness, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, SetMaxNumIterations, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, SetNumIterations, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UClothingSimulationInteractor, SetNumSubsteps, (int), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UToolMenu, AddDynamicSectionScript, (const FName, UToolMenuSectionDynamic*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenu, AddMenuEntry, (const FName, const FToolMenuEntry&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenu, AddMenuEntryObject, (UToolMenuEntryScript*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenu, AddSectionScript, (const FName, const FText&, const FName, const EToolMenuInsertType), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenu, AddSubMenuScript, (const FName, const FName, const FName, const FText&, const FText&), ERASE_ARGUMENT_PACK(UToolMenu*)) },
{ ERASE_METHOD_PTR(UToolMenu, InitMenu, (const FToolMenuOwner, FName, FName, EMultiBoxType), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UToolMenuEntryScript, CanExecute, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, ConstructMenuEntry, (UToolMenu*, const FName, const FToolMenuContext&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, Execute, (const FToolMenuContext&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, GetCheckState, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(ECheckBoxState)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, GetIcon, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(FScriptSlateIcon)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, GetLabel, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(FText)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, GetToolTip, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(FText)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, InitEntry, (const FName, const FName, const FName, const FName, const FText&, const FText&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, IsVisible, (const FToolMenuContext&)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UToolMenuEntryScript, RegisterMenuEntry, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UToolMenus, ExtendMenu, (const FName), ERASE_ARGUMENT_PACK(UToolMenu*)) },
{ ERASE_METHOD_PTR(UToolMenus, FindMenu, (const FName), ERASE_ARGUMENT_PACK(UToolMenu*)) },
{ ERASE_METHOD_PTR(UToolMenus, IsMenuRegistered, (const FName)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UToolMenus, RefreshAllWidgets, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, RefreshMenuWidget, (const FName), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UToolMenus, RegisterMenu, (FName, const FName, EMultiBoxType, bool), ERASE_ARGUMENT_PACK(UToolMenu*)) },
{ ERASE_METHOD_PTR(UToolMenus, RemoveEntry, (const FName, const FName, const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, RemoveMenu, (const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, RemoveSection, (const FName, const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, SetSectionLabel, (const FName, const FName, const FText), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, SetSectionPosition, (const FName, const FName, const FName, const EToolMenuInsertType), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UToolMenus, UnregisterOwnerByName, (FName), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UToolMenuSectionDynamic, ConstructSections, (UToolMenu*, const FToolMenuContext&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UInterchangeFactoryBase, GetFactoryClass, ()const, ERASE_ARGUMENT_PACK(UClass*)) },


{ ERASE_METHOD_PTR(UInterchangeSourceData, GetFilename, ()const, ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeSourceData, SetFilename, (const FString&)const, ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UInterchangePipelineBase, DoesPropertyStatesExist, (const FName)const, ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, FindOrAddPropertyStates, (const FName), ERASE_ARGUMENT_PACK(FInterchangePipelinePropertyStates&)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedExecuteExportPipeline, (UInterchangeBaseNodeContainer*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedExecutePipeline, (UInterchangeBaseNodeContainer*, const TArray<UInterchangeSourceData*>&, const FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedExecutePostFactoryPipeline, (const UInterchangeBaseNodeContainer*, const FString&, UObject*, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedExecutePostImportPipeline, (const UInterchangeBaseNodeContainer*, const FString&, UObject*, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedGetPipelineDisplayName, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangePipelineBase, ScriptedSetReimportSourceIndex, (UClass*, const int), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddBooleanAttribute, (const FString&, const bool&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddDoubleAttribute, (const FString&, const float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddFloatAttribute, (const FString&, const float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddGuidAttribute, (const FString&, const FGuid&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddInt32Attribute, (const FString&, const int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddLinearColorAttribute, (const FString&, const FLinearColor&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddStringAttribute, (const FString&, const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddTargetNodeUid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, AddVector2Attribute, (const FString&, const FVector2f&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetAssetName, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetBooleanAttribute, (const FString&, bool&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetDisplayLabel, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetDoubleAttribute, (const FString&, float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetFloatAttribute, (const FString&, float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetGuidAttribute, (const FString&, FGuid&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetInt32Attribute, (const FString&, int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetLinearColorAttribute, (const FString&, FLinearColor&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetNodeContainerType, (), ERASE_ARGUMENT_PACK(EInterchangeNodeContainerType)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetParentUid, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetStringAttribute, (const FString&, FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetTargetNodeCount, (), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetTargetNodeUids, (TArray<FString>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetUniqueID, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, GetVector2Attribute, (const FString&, FVector2f&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, InitializeNode, (const FString&, const FString&, const EInterchangeNodeContainerType), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, IsEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, RemoveAttribute, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, RemoveTargetNodeUid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, SetAssetName, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, SetDisplayLabel, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, SetEnabled, (const bool), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNode, SetParentUid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, AddNode, (UInterchangeBaseNode*), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, ComputeChildrenCache, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetFactoryNode, (const FString&), ERASE_ARGUMENT_PACK(UInterchangeFactoryBaseNode*)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetNode, (const FString&), ERASE_ARGUMENT_PACK(const UInterchangeBaseNode*)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetNodeChildren, (const FString&, int), ERASE_ARGUMENT_PACK(UInterchangeBaseNode*)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetNodeChildrenCount, (const FString&), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetNodeChildrenUids, (const FString&), ERASE_ARGUMENT_PACK(TArray<FString>)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetNodes, (const UClass*, TArray<FString>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, GetRoots, (TArray<FString>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, IsNodeUidValid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, LoadFromFile, (const FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, ReplaceNode, (const FString&, UInterchangeFactoryBaseNode*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, Reset, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, ResetChildrenCache, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, SaveToFile, (const FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeBaseNodeContainer, SetNodeParentUid, (const FString&, const FString&), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, AddFactoryDependencyUid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetCustomReferenceObject, (FSoftObjectPath&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetCustomSubPath, (FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetFactoryDependencies, (TArray<FString>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetFactoryDependenciesCount, (), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetFactoryDependency, (const int, FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, GetReimportStrategyFlags, (), ERASE_ARGUMENT_PACK(EReimportStrategyFlags)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, RemoveFactoryDependencyUid, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, SetCustomReferenceObject, (const FSoftObjectPath&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, SetCustomSubPath, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, SetForceNodeReimport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, SetReimportStrategyFlags, (const EReimportStrategyFlags&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, SetSkipNodeImport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, ShouldForceNodeReimport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, ShouldSkipNodeImport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, UnsetForceNodeReimport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeFactoryBaseNode, UnsetSkipNodeImport, (), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomAnimatedTimeEnd, (float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomAnimatedTimeStart, (float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomImportUnusedMaterial, (bool&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomSourceFrameRateDenominator, (int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomSourceFrameRateNumerator, (int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomSourceTimelineEnd, (float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, GetCustomSourceTimelineStart, (float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, InitializeSourceNode, (const FString&, const FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomAnimatedTimeEnd, (const float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomAnimatedTimeStart, (const float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomImportUnusedMaterial, (const bool&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomSourceFrameRateDenominator, (const int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomSourceFrameRateNumerator, (const int&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomSourceTimelineEnd, (const float&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UInterchangeSourceNode, SetCustomSourceTimelineStart, (const float&), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UMovieSceneCaptureProtocolBase, GetState, (), ERASE_ARGUMENT_PACK(EMovieSceneCaptureProtocolState)) },
{ ERASE_METHOD_PTR(UMovieSceneCaptureProtocolBase, IsCapturing, (), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UMovieSceneCapture, GetAudioCaptureProtocol, (), ERASE_ARGUMENT_PACK(UMovieSceneCaptureProtocolBase*)) },
{ ERASE_METHOD_PTR(UMovieSceneCapture, GetImageCaptureProtocol, (), ERASE_ARGUMENT_PACK(UMovieSceneCaptureProtocolBase*)) },
{ ERASE_METHOD_PTR(UMovieSceneCapture, SetAudioCaptureProtocolType, (TSubclassOf<UMovieSceneCaptureProtocolBase>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMovieSceneCapture, SetImageCaptureProtocolType, (TSubclassOf<UMovieSceneCaptureProtocolBase>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMovieSceneCapture, SetImageCaptureProtocol, (UMovieSceneImageCaptureProtocolBase), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMovieSceneCapture, SetAudioCaptureProtocol, (UMovieSceneAudioCaptureProtocolBase), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, GenerateFilename, (const FFrameMetrics&), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, GetCurrentFrameMetrics, (), ERASE_ARGUMENT_PACK(FFrameMetrics)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnBeginFinalize, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnCanFinalize, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnCaptureFrame, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnFinalize, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnPauseCapture, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnPixelsReceived, (const FCapturedPixels&, const FCapturedPixelsID&, FFrameMetrics), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnPreTick, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnSetup, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnStartCapture, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnTick, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, OnWarmUp, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, ResolveBuffer, (UTexture, const FCapturedPixelsID&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, StartCapturingFinalPixels, (const FCapturedPixelsID&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UUserDefinedCaptureProtocol, StopCapturingFinalPixels, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UUserDefinedImageCaptureProtocol, GenerateFilenameForBuffer, (UTexture*, const FCapturedPixelsID&), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UUserDefinedImageCaptureProtocol, GenerateFilenameForCurrentFrame, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UUserDefinedImageCaptureProtocol, WriteImageToDisk, (const FCapturedPixels&, const FCapturedPixelsID&, const FFrameMetrics&, bool), ERASE_ARGUMENT_PACK(void)) },


//{ ERASE_METHOD_PTR(AActor, IsActorInitialized, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, HasActorBegunPlay, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsHidden, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, GetActorNameOrLabel, (), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(AActor, GetGameInstance, (), ERASE_ARGUMENT_PACK(UGameInstance*)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentsByClass, (?&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentsByClass, (UClass*, ?&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorInstigator, (), ERASE_ARGUMENT_PACK(APawn*)) },
//{ ERASE_METHOD_PTR(AActor, GetActorInstigatorController, (), ERASE_ARGUMENT_PACK(AController*)) },
//{ ERASE_METHOD_PTR(AActor, ActorHasTag, (FName), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, AddTickPrerequisiteActor, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddTickPrerequisiteComponent, (UActorComponent*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, CanTriggerResimulation, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, CreateInputComponent, (TSubclassOf<UInputComponent>), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, DetachRootComponentFromParent, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, DisableInput, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, EnableInput, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, FindComponentByTag, (TSubclassOf<UActorComponent>, FName), ERASE_ARGUMENT_PACK(UActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, FlushNetDormancy, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ForceNetUpdate, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorBounds, (bool, FVector&, FVector&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorEnableCollision, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, GetActorEyesViewPoint, (FVector&, FRotator&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorForwardVector, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorLabel, (bool), ERASE_ARGUMENT_PACK(const FString&)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRelativeScale3D, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRightVector, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorScale3D, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorTickInterval, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetActorTimeDilation, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetActorUpVector, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetAllChildActors, (TArray<AActor*>&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetAttachedActors, (TArray<AActor*>&, bool, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetAttachParentActor, (), ERASE_ARGUMENT_PACK(AActor*)) },
//{ ERASE_METHOD_PTR(AActor, GetAttachParentSocketName, (), ERASE_ARGUMENT_PACK(FName)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentByClass, (TSubclassOf<UActorComponent>), ERASE_ARGUMENT_PACK(UActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentsByInterface, (TSubclassOf<UInterface>), ERASE_ARGUMENT_PACK(TArray<UActorComponent*>)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentsByTag, (TSubclassOf<UActorComponent>, FName), ERASE_ARGUMENT_PACK(TArray<UActorComponent*>)) },
//{ ERASE_METHOD_PTR(AActor, GetDefaultActorLabel, (), ERASE_ARGUMENT_PACK(FString)) },
//{ ERASE_METHOD_PTR(AActor, GetDistanceTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetDotProductTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetFolderPath, (), ERASE_ARGUMENT_PACK(FName)) },
//{ ERASE_METHOD_PTR(AActor, GetGameTimeSinceCreation, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetHorizontalDistanceTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetHorizontalDotProductTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetInstigator, (), ERASE_ARGUMENT_PACK(APawn*)) },
//{ ERASE_METHOD_PTR(AActor, GetInstigatorController, (), ERASE_ARGUMENT_PACK(AController*)) },
//{ ERASE_METHOD_PTR(AActor, GetLevel, (), ERASE_ARGUMENT_PACK(ULevel*)) },
//{ ERASE_METHOD_PTR(AActor, GetLevelTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
//{ ERASE_METHOD_PTR(AActor, GetLifeSpan, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetLocalRole, (), ERASE_ARGUMENT_PACK(ENetRole)) },
//{ ERASE_METHOD_PTR(AActor, GetOverlappingActors, (TArray<AActor*>&, TSubclassOf<AActor>), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetOverlappingComponents, (TArray<UPrimitiveComponent*>&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetOwner, (), ERASE_ARGUMENT_PACK(AActor*)) },
//{ ERASE_METHOD_PTR(AActor, GetParentActor, (), ERASE_ARGUMENT_PACK(AActor*)) },
//{ ERASE_METHOD_PTR(AActor, GetParentComponent, (), ERASE_ARGUMENT_PACK(UChildActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, GetPhysicsReplicationMode, (), ERASE_ARGUMENT_PACK(EPhysicsReplicationMode)) },
//{ ERASE_METHOD_PTR(AActor, GetRayTracingGroupId, (), ERASE_ARGUMENT_PACK(int)) },
//{ ERASE_METHOD_PTR(AActor, GetRemoteRole, (), ERASE_ARGUMENT_PACK(ENetRole)) },
//{ ERASE_METHOD_PTR(AActor, GetResimulationThreshold, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetSquaredDistanceTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetSquaredHorizontalDistanceTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, GetTickableWhenPaused, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, GetActorTransform, (), ERASE_ARGUMENT_PACK(const FTransform&)) },
//{ ERASE_METHOD_PTR(AActor, GetVelocity, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetVerticalDistanceTo, (const AActor*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(AActor, HasAuthority, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsActorBeingDestroyed, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsActorTickEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsChildActor, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsEditable, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsHiddenEd, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsHiddenEdAtStartup, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsOverlappingActor, (const AActor*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsSelectable, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, IsTemporarilyHiddenInEditor, (bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalOffset, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldOffset, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldTransformKeepScale, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AttachRootComponentTo, (USceneComponent*, FName, EAttachLocation, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AttachRootComponentToActor, (AActor*, FName, EAttachLocation, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AttachToActor, (AActor*, FName, EAttachmentRule, EAttachmentRule, EAttachmentRule, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, AttachToComponent, (USceneComponent*, FName, EAttachmentRule, EAttachmentRule, EAttachmentRule, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, DestroyActor, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, DetachFromActor, (EDetachmentRule, EDetachmentRule, EDetachmentRule), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
//{ ERASE_METHOD_PTR(AActor, GetComponentsByClass, (TSubclassOf<UActorComponent>), ERASE_ARGUMENT_PACK(TArray<UActorComponent*>)) },
//{ ERASE_METHOD_PTR(AActor, GetRootComponent, (), ERASE_ARGUMENT_PACK(USceneComponent*)) },
//{ ERASE_METHOD_PTR(AActor, OnBecomeViewTarget, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, OnEndViewTarget, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, OnReset, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLocation, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLocationAndRotation, (FVector, FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeLocation, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRotation, (FRotator, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetActorTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, Teleport, (FVector, FRotator), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, MakeNoise, (float, APawn*, FVector), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, PrestreamTextures, (float, bool, int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorBeginCursorOver, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorBeginOverlap, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorEndCursorOver, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorEndOverlap, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnClicked, (FKey), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnInputTouchBegin, (const ETouchIndex), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnInputTouchEnd, (const ETouchIndex), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnInputTouchEnter, (const ETouchIndex), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnInputTouchLeave, (const ETouchIndex), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ActorOnReleased, (FKey), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AnyDamage, (float, const UDamageType*, AController*, AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AsyncPhysicsTick, (float, float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, BeginPlay, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, Destroyed, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, EndPlay, (EEndPlayReason), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, Hit, (UPrimitiveComponent*, AActor*, UPrimitiveComponent*, bool, FVector, FVector, FVector, const FHitResult&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, PointDamage, (float, const UDamageType*, FVector, FVector, UPrimitiveComponent*, FName, FVector, AController*, AActor*, const FHitResult&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, RadialDamage, (float, const UDamageType*, FVector, const FHitResult&, AController*, AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, Tick, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, RemoveTickPrerequisiteActor, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, RemoveTickPrerequisiteComponent, (UActorComponent*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorEnableCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorHiddenInGame, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLabel, (const FString&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeScale3D, (FVector), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorScale3D, (FVector), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorTickEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorTickInterval, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetAutoDestroyWhenFinished, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetFolderPath, (const FName&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetIsTemporarilyHiddenInEditor, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetLifeSpan, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetNetDormancy, (ENetDormancy), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetOwner, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetPhysicsReplicationMode, (const EPhysicsReplicationMode), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetRayTracingGroupId, (int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetReplicateMovement, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetReplicates, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetTickableWhenPaused, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetTickGroup, (ETickingGroup), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, TearOff, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, ConstructionScript, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, WasRecentlyRendered, (float), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbAutoDestroyWhenFinished, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalOffset, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorLocalTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldOffset, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AddActorWorldTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AttachToActor, (AActor*, FName, EAttachmentRule), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, AttachToComponent, (USceneComponent*, FName, EAttachmentRule), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetActorQuat, (), ERASE_ARGUMENT_PACK(FQuat)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRelativeLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRelativeRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
//{ ERASE_METHOD_PTR(AActor, GetActorRelativeTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
//{ ERASE_METHOD_PTR(AActor, RerunConstructionScripts, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLocation, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLocationAndRotation, (const FVector&, const FRotator&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorLocationAndRotation, (const FVector&, const FQuat&, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorQuat, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeLocation, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRelativeTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetActorTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbRunConstructionScriptOnDrag, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbOnlyRelevantToOwner, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbOnlyRelevantToOwner, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbAlwaysRelevant, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbAlwaysRelevant, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbReplicateMovement, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbCallPreReplication, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbCallPreReplicationForReplay, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbHidden, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbHidden, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbIsMainWorldOnly, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbNetLoadOnClient, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbNetUseOwnerRelevancy, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbNetUseOwnerRelevancy, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbRelevantForLevelBounds, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbReplayRewindable, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbAllowTickBeforeBeginPlay, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbAutoDestroyWhenFinished, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, GetbCanBeDamaged, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbCanBeDamaged, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbBlockInput, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbFindCameraComponentWhenViewTarget, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbFindCameraComponentWhenViewTarget, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbGenerateOverlapEventsDuringLevelStreaming, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbGenerateOverlapEventsDuringLevelStreaming, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbIgnoresOriginShifting, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbEnableAutoLODGeneration, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbEnableAutoLODGeneration, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbIsEditorOnlyActor, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbReplicates, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbReplicates, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbCanBeInCluster, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetbReplicateUsingRegisteredSubObjectList, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(AActor, SetbReplicateUsingRegisteredSubObjectList, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbAsyncPhysicsTickEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, GetNetDormancy, (), ERASE_ARGUMENT_PACK(const ENetDormancy&)) },
//{ ERASE_METHOD_PTR(AActor, SetInstigator, (APawn*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetRootComponent, (USceneComponent*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbOptimizeBPComponentData, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, SetbIsSpatiallyLoaded, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(AActor, CreateComponent, (const TSubclassOf<UActorComponent>&, const FName&), ERASE_ARGUMENT_PACK(UActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, GetComponent, (const TSubclassOf<UActorComponent>&, const FName&), ERASE_ARGUMENT_PACK(UActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, GetOrCreateComponent, (const TSubclassOf<UActorComponent>&, const FName&), ERASE_ARGUMENT_PACK(UActorComponent*)) },
//{ ERASE_METHOD_PTR(AActor, GetAllComponents, (UClass*, TArray<UActorComponent*>&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UMovieSceneUserImportFBXControlRigSettings, LoadControlMappingsFromPreset, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UMovieSceneUserExportFBXControlRigSettings, LoadControlMappingsFromPreset, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMovieSceneUserExportFBXControlRigSettings, GetbASCII, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMovieSceneUserExportFBXControlRigSettings, SetbASCII, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMovieSceneUserExportFBXControlRigSettings, GetbExportLocalTime, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMovieSceneUserExportFBXControlRigSettings, SetbExportLocalTime, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(USequencerOutlinerScriptingObject, GetChildren, (FSequencerViewModelScriptingStruct, FName), ERASE_ARGUMENT_PACK(TArray<FSequencerViewModelScriptingStruct>)) },
{ ERASE_METHOD_PTR(USequencerOutlinerScriptingObject, GetRootNode, (), ERASE_ARGUMENT_PACK(FSequencerViewModelScriptingStruct)) },
{ ERASE_METHOD_PTR(USequencerOutlinerScriptingObject, GetSelection, (), ERASE_ARGUMENT_PACK(TArray<FSequencerViewModelScriptingStruct>)) },
{ ERASE_METHOD_PTR(USequencerOutlinerScriptingObject, SetSelection, (const TArray<FSequencerViewModelScriptingStruct>&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UContentBrowserAssetContextMenuContext, GetSelectedObjects, (), ERASE_ARGUMENT_PACK(TArray<UObject*>)) },
{ ERASE_METHOD_PTR(UContentBrowserAssetContextMenuContext, LoadSelectedObjects, (TSet<FName>), ERASE_ARGUMENT_PACK(TArray<UObject*>)) },
{ ERASE_METHOD_PTR(UContentBrowserAssetContextMenuContext, LoadSelectedObjectsIfNeeded, (), ERASE_ARGUMENT_PACK(TArray<UObject*>)) },


{ ERASE_METHOD_PTR(USequencerModuleOutlinerScriptingObject, GetNextKey, (const TArray<FSequencerViewModelScriptingStruct>&, FFrameNumber, EMovieSceneTimeUnit), ERASE_ARGUMENT_PACK(FFrameNumber)) },
{ ERASE_METHOD_PTR(USequencerModuleOutlinerScriptingObject, GetPreviousKey, (const TArray<FSequencerViewModelScriptingStruct>&, FFrameNumber, EMovieSceneTimeUnit), ERASE_ARGUMENT_PACK(FFrameNumber)) },


{ ERASE_METHOD_PTR(USequencerModuleScriptingLayer, GetOutliner, (), ERASE_ARGUMENT_PACK(USequencerModuleOutlinerScriptingObject*)) },


//{ ERASE_METHOD_PTR(UWidget, ForceLayoutPrepass, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, ForceVolatile, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, GetAccessibleSummaryText, (), ERASE_ARGUMENT_PACK(FText)) },
//{ ERASE_METHOD_PTR(UWidget, GetAccessibleText, (), ERASE_ARGUMENT_PACK(FText)) },
//{ ERASE_METHOD_PTR(UWidget, GetCachedGeometry, (), ERASE_ARGUMENT_PACK(const FGeometry&)) },
//{ ERASE_METHOD_PTR(UWidget, GetClipping, (), ERASE_ARGUMENT_PACK(EWidgetClipping)) },
//{ ERASE_METHOD_PTR(UWidget, GetDesiredSize, (), ERASE_ARGUMENT_PACK(FVector2D)) },
//{ ERASE_METHOD_PTR(UWidget, GetGameInstance, (), ERASE_ARGUMENT_PACK(UGameInstance*)) },
//{ ERASE_METHOD_PTR(UWidget, GetIsEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, GetOwningLocalPlayer, (), ERASE_ARGUMENT_PACK(ULocalPlayer*)) },
//{ ERASE_METHOD_PTR(UWidget, GetOwningPlayer, (), ERASE_ARGUMENT_PACK(APlayerController*)) },
//{ ERASE_METHOD_PTR(UWidget, GetPaintSpaceGeometry, (), ERASE_ARGUMENT_PACK(const FGeometry&)) },
//{ ERASE_METHOD_PTR(UWidget, GetParent, (), ERASE_ARGUMENT_PACK(UPanelWidget*)) },
//{ ERASE_METHOD_PTR(UWidget, GetRenderOpacity, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UWidget, GetRenderTransformAngle, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UWidget, GetTickSpaceGeometry, (), ERASE_ARGUMENT_PACK(const FGeometry&)) },
//{ ERASE_METHOD_PTR(UWidget, GetVisibility, (), ERASE_ARGUMENT_PACK(ESlateVisibility)) },
//{ ERASE_METHOD_PTR(UWidget, HasAnyUserFocus, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasFocusedDescendants, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasKeyboardFocus, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasMouseCapture, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasMouseCaptureByUser, (int, int), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasUserFocus, (APlayerController*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, HasUserFocusedDescendants, (APlayerController*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, InvalidateLayoutAndVolatility, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, IsHovered, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, IsInViewport, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, IsRendered, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, IsVisible, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, AddFieldValueChangedDelegate, (FFieldNotificationId, FFieldValueChangedDynamicDelegate, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UWidget, BroadcastFieldValueChanged, (FFieldNotificationId), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, RemoveFieldValueChangedDelegate, (FFieldNotificationId, FFieldValueChangedDynamicDelegate, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UWidget, RemoveFromParent, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, ResetCursor, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetAllNavigationRules, (EUINavigationRule, FName), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetClipping, (EWidgetClipping), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetCursor, (EMouseCursor), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetFocus, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetIsEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetKeyboardFocus, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetNavigationRule, (EUINavigation, EUINavigationRule, FName), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetNavigationRuleBase, (EUINavigation, EUINavigationRule), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetNavigationRuleCustom, (EUINavigation, FCustomWidgetNavigationDelegate, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UWidget, SetNavigationRuleCustomBoundary, (EUINavigation, FCustomWidgetNavigationDelegate, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UWidget, SetNavigationRuleExplicit, (EUINavigation, UWidget*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderOpacity, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderScale, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderShear, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderTransform, (FWidgetTransform), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderTransformAngle, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderTransformPivot, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetRenderTranslation, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetToolTip, (UWidget*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetToolTipText, (const FText&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetUserFocus, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetVisibility, (ESlateVisibility), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetToolTipWidget, (UWidget*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, GetbIsEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, SetbIsEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, GetRenderTransform, (), ERASE_ARGUMENT_PACK(const FWidgetTransform&)) },
//{ ERASE_METHOD_PTR(UWidget, GetToolTipText, (), ERASE_ARGUMENT_PACK(const FText&)) },
//{ ERASE_METHOD_PTR(UWidget, GetToolTipWidget, (), ERASE_ARGUMENT_PACK(UWidget*)) },
//{ ERASE_METHOD_PTR(UWidget, GetRenderTransformPivot, (), ERASE_ARGUMENT_PACK(const FVector2D&)) },
//{ ERASE_METHOD_PTR(UWidget, SetbOverride_Cursor, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetbOverrideAccessibleDefaults, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetbCanChildrenBeAccessible, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetAccessibleText, (const FText&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, SetAccessibleSummaryText, (const FText&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, GetbIsVolatile, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UWidget, SetbIsVolatile, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UWidget, GetCursor, (), ERASE_ARGUMENT_PACK(const EMouseCursor&)) },


//{ ERASE_METHOD_PTR(UUserWidget, GetPaletteCategory, (), ERASE_ARGUMENT_PACK(FText)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetPaletteCategory, (const FText&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetRootWidget, (), ERASE_ARGUMENT_PACK(UWidget*)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetRootWidget, (UWidget*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, ConstructWidget, (UClass*, FName), ERASE_ARGUMENT_PACK(UWidget*)) },
//{ ERASE_METHOD_PTR(UUserWidget, RemoveWidget, (UWidget*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetAllWidgets, (TArray<UWidget*>&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, AddExtension, (TSubclassOf<UUserWidgetExtension>), ERASE_ARGUMENT_PACK(UUserWidgetExtension*)) },
//{ ERASE_METHOD_PTR(UUserWidget, AddToPlayerScreen, (int), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, AddToViewport, (int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, BindToAnimationEvent, (UWidgetAnimation*, FWidgetAnimationDynamicEvent, EWidgetAnimationEvent, FName), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, BindToAnimationFinished, (UWidgetAnimation*, FWidgetAnimationDynamicEvent, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UUserWidget, BindToAnimationStarted, (UWidgetAnimation*, FWidgetAnimationDynamicEvent, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UUserWidget, CancelLatentActions, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, Construct, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, Destruct, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, FlushAnimations, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetAlignmentInViewport, (), ERASE_ARGUMENT_PACK(FVector2D)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetAnchorsInViewport, (), ERASE_ARGUMENT_PACK(FAnchors)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetAnimationCurrentTime, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetExtension, (TSubclassOf<UUserWidgetExtension>), ERASE_ARGUMENT_PACK(UUserWidgetExtension*)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetExtensions, (TSubclassOf<UUserWidgetExtension>), ERASE_ARGUMENT_PACK(TArray<UUserWidgetExtension*>)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetOwningPlayerCameraManager, (), ERASE_ARGUMENT_PACK(APlayerCameraManager*)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetOwningPlayerPawn, (), ERASE_ARGUMENT_PACK(APawn*)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsAnimationPlaying, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsAnimationPlayingForward, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsAnyAnimationPlaying, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsInteractable, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsListeningForInputAction, (FName), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, IsPlayingAnimation, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, ListenForInputAction, (FName, EInputEvent, bool, FOnInputAction, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UUserWidget, OnAddedToFocusPath, (FFocusEvent), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnAnalogValueChanged, (FGeometry, FAnalogInputEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnAnimationFinished, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnAnimationStarted, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDragCancelled, (const FPointerEvent&, UDragDropOperation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDragDetected, (FGeometry, const FPointerEvent&, UDragDropOperation*&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDragEnter, (FGeometry, FPointerEvent, UDragDropOperation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDragLeave, (FPointerEvent, UDragDropOperation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDragOver, (FGeometry, FPointerEvent, UDragDropOperation*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnDrop, (FGeometry, FPointerEvent, UDragDropOperation*), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnFocusLost, (FFocusEvent), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnFocusReceived, (FGeometry, FFocusEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnInitialized, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnKeyChar, (FGeometry, FCharacterEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnKeyDown, (FGeometry, FKeyEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnKeyUp, (FGeometry, FKeyEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMotionDetected, (FGeometry, FMotionEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseButtonDoubleClick, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseButtonDown, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseButtonUp, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseCaptureLost, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseEnter, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseLeave, (const FPointerEvent&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseMove, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnMouseWheel, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnPaint, (FPaintContext&), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnPreviewKeyDown, (FGeometry, FKeyEvent), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnPreviewMouseButtonDown, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnRemovedFromFocusPath, (FFocusEvent), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnTouchEnded, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnTouchForceChanged, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnTouchGesture, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnTouchMoved, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, OnTouchStarted, (FGeometry, const FPointerEvent&), ERASE_ARGUMENT_PACK(FEventReply)) },
//{ ERASE_METHOD_PTR(UUserWidget, PauseAnimation, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UUserWidget, PlayAnimation, (UWidgetAnimation*, float, int, EUMGSequencePlayMode, float, bool), ERASE_ARGUMENT_PACK(UUMGSequencePlayer*)) },
//{ ERASE_METHOD_PTR(UUserWidget, PlayAnimationForward, (UWidgetAnimation*, float, bool), ERASE_ARGUMENT_PACK(UUMGSequencePlayer*)) },
//{ ERASE_METHOD_PTR(UUserWidget, PlayAnimationReverse, (UWidgetAnimation*, float, bool), ERASE_ARGUMENT_PACK(UUMGSequencePlayer*)) },
//{ ERASE_METHOD_PTR(UUserWidget, PlayAnimationTimeRange, (UWidgetAnimation*, float, float, int, EUMGSequencePlayMode, float, bool), ERASE_ARGUMENT_PACK(UUMGSequencePlayer*)) },
//{ ERASE_METHOD_PTR(UUserWidget, PlaySound, (USoundBase*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, PreConstruct, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueuePauseAnimation, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueuePlayAnimation, (UWidgetAnimation*, float, int, EUMGSequencePlayMode, float, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueuePlayAnimationForward, (UWidgetAnimation*, float, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueuePlayAnimationReverse, (UWidgetAnimation*, float, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueuePlayAnimationTimeRange, (UWidgetAnimation*, float, float, int, EUMGSequencePlayMode, float, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueueStopAllAnimations, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, QueueStopAnimation, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, RegisterInputComponent, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, RemoveExtension, (UUserWidgetExtension*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, RemoveExtensions, (TSubclassOf<UUserWidgetExtension>), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, RemoveFromViewport, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, ReverseAnimation, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetAlignmentInViewport, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetAnchorsInViewport, (FAnchors), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetAnimationCurrentTime, (const UWidgetAnimation*, float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetColorAndOpacity, (FLinearColor), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetDesiredSizeInViewport, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetForegroundColor, (FSlateColor), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetInputActionBlocking, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetInputActionPriority, (int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetNumLoopsToPlay, (const UWidgetAnimation*, int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetOwningPlayer, (APlayerController*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetPadding, (FMargin), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetPlaybackSpeed, (const UWidgetAnimation*, float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetPositionInViewport, (FVector2D, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, StopAllAnimations, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, StopAnimation, (const UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, StopAnimationsAndLatentActions, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, StopListeningForAllInputActions, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, StopListeningForInputAction, (FName, EInputEvent), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, Tick, (FGeometry, float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, UnbindAllFromAnimationFinished, (UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, UnbindAllFromAnimationStarted, (UWidgetAnimation*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, UnbindFromAnimationFinished, (UWidgetAnimation*, FWidgetAnimationDynamicEvent, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UUserWidget, UnbindFromAnimationStarted, (UWidgetAnimation*, FWidgetAnimationDynamicEvent, ERASE_ARGUMENT_PACK(void))) },
//{ ERASE_METHOD_PTR(UUserWidget, UnregisterInputComponent, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetPriority, (int), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetbStopAction, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetColorAndOpacity, (), ERASE_ARGUMENT_PACK(const FLinearColor&)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetForegroundColor, (), ERASE_ARGUMENT_PACK(const FSlateColor&)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetPadding, (), ERASE_ARGUMENT_PACK(const FMargin&)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetPriority, (), ERASE_ARGUMENT_PACK(const int&)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetbIsFocusable, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UUserWidget, SetbIsFocusable, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UUserWidget, GetbStopAction, (), ERASE_ARGUMENT_PACK(bool)) },


//{ ERASE_METHOD_PTR(UActorComponent, MarkRenderStateDirty, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, HasBegunPlay, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbTickInEditor, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbIsEditorOnly, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetComponentCreationMethod, (), ERASE_ARGUMENT_PACK(EComponentCreationMethod)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetIsVisualizationComponent, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, IsVisualizationComponent, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, Activate, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, AddTickPrerequisiteActor, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, AddTickPrerequisiteComponent, (UActorComponent*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, ComponentHasTag, (FName), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, Deactivate, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetComponentTickInterval, (), ERASE_ARGUMENT_PACK(float)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetOwner, (), ERASE_ARGUMENT_PACK(AActor*)) },
//{ ERASE_METHOD_PTR(UActorComponent, IsActive, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, IsBeingDestroyed, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, IsComponentTickEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, DestroyComponent, (UObject*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, AsyncPhysicsTick, (float, float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, BeginPlay, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, EndPlay, (EEndPlayReason), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, Tick, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, RemoveTickPrerequisiteActor, (AActor*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, RemoveTickPrerequisiteComponent, (UActorComponent*), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetActive, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetAutoActivate, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetComponentTickEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetComponentTickInterval, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetComponentTickIntervalAndCooldown, (float), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetIsReplicated, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetTickableWhenPaused, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetTickGroup, (ETickingGroup), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, ToggleActive, (), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetbReplicateUsingRegisteredSubObjectList, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbReplicateUsingRegisteredSubObjectList, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetbReplicates, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbReplicates, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetbAutoActivate, (), ERASE_ARGUMENT_PACK(bool)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbAutoActivate, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbEditableWhenInherited, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, SetbCanEverAffectNavigation, (bool), ERASE_ARGUMENT_PACK(void)) },
//{ ERASE_METHOD_PTR(UActorComponent, GetbIsEditorOnly, (), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(USceneComponent, GetChildComponentByClass, (TSubclassOf<USceneComponent>), ERASE_ARGUMENT_PACK(USceneComponent*)) },
{ ERASE_METHOD_PTR(USceneComponent, GetChildrenComponentsByClass, (UClass*, bool, ?&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, DetachFromParent, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, DoesSocketExist, (FName), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, GetAllSocketNames, (), ERASE_ARGUMENT_PACK(TArray<FName>)) },
{ ERASE_METHOD_PTR(USceneComponent, GetAttachParent, (), ERASE_ARGUMENT_PACK(USceneComponent*)) },
{ ERASE_METHOD_PTR(USceneComponent, GetAttachSocketName, (), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(USceneComponent, GetChildComponent, (int), ERASE_ARGUMENT_PACK(USceneComponent*)) },
{ ERASE_METHOD_PTR(USceneComponent, GetChildrenComponents, (bool, TArray<USceneComponent*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetComponentVelocity, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetForwardVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetNumChildrenComponents, (), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(USceneComponent, GetParentComponents, (TArray<USceneComponent*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetPhysicsVolume, (), ERASE_ARGUMENT_PACK(APhysicsVolume*)) },
{ ERASE_METHOD_PTR(USceneComponent, GetRelativeTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(USceneComponent, GetRightVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetShouldUpdatePhysicsVolume, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, GetSocketLocation, (FName), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetSocketRotation, (FName), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(USceneComponent, GetSocketTransform, (FName, ERelativeTransformSpace), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(USceneComponent, GetUpVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, IsAnySimulatingPhysics, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, IsSimulatingPhysics, (FName), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, IsVisible, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalOffset, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddRelativeLocation, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddRelativeRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldOffset, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldTransformKeepScale, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AttachTo, (USceneComponent*, FName, EAttachLocation, bool), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, AttachToComponent, (USceneComponent*, FName, EAttachmentRule, EAttachmentRule, EAttachmentRule, bool), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, DetachFromComponent, (EDetachmentRule, EDetachmentRule, EDetachmentRule, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetWorldLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetWorldRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(USceneComponent, GetWorldScale, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetWorldTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeLocation, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeLocationAndRotation, (FVector, FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldLocation, (FVector, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldLocationAndRotation, (FVector, FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldRotation, (FRotator, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldTransform, (const FTransform&, bool, FHitResult&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, ResetRelativeTransform, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetAbsolute, (bool, bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetHiddenInGame, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetMobility, (EComponentMobility), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeScale3D, (FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetShouldUpdatePhysicsVolume, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetVisibility, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldScale3D, (FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, ToggleVisibility, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbShouldUpdatePhysicsVolume, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbShouldUpdatePhysicsVolume, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalOffset, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddLocalTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddRelativeLocation, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddRelativeRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddRelativeRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldOffset, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AddWorldTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, AttachToComponent, (USceneComponent*, const FName&, EAttachmentRule), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetBounds, (), ERASE_ARGUMENT_PACK(FBoxSphereBounds)) },
{ ERASE_METHOD_PTR(USceneComponent, GetComponentQuat, (), ERASE_ARGUMENT_PACK(FQuat)) },
{ ERASE_METHOD_PTR(USceneComponent, GetRelativeLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetRelativeRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(USceneComponent, GetRelativeScale3D, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetShapeCenter, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(USceneComponent, GetSocketQuaternion, (const FName&), ERASE_ARGUMENT_PACK(FQuat)) },
{ ERASE_METHOD_PTR(USceneComponent, IsAttachedTo, (const USceneComponent*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, IsAttachedTo, (const AActor*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbVisualizeComponent, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetComponentQuat, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeLocation, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeLocationAndRotation, (const FVector&, const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeLocationAndRotation, (const FVector&, const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetRelativeTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldLocation, (const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldLocationAndRotation, (const FVector&, const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldLocationAndRotation, (const FVector&, const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldRotation, (const FQuat&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, SetWorldTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbAbsoluteLocation, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbAbsoluteLocation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbAbsoluteRotation, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbAbsoluteRotation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbAbsoluteScale, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbAbsoluteScale, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbVisible, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbVisible, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbHiddenInGame, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbHiddenInGame, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetbUseAttachParentBound, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(USceneComponent, SetbUseAttachParentBound, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(USceneComponent, GetMobility, (), ERASE_ARGUMENT_PACK(const EComponentMobility&)) },


{ ERASE_METHOD_PTR(UPrimitiveComponent, GetBoundingBoxExtents, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetBoundsOrigin, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetBoundsExtent, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetBoundsRadius, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbSelectable, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbSelectable, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetLightmapType, (ELightmapType), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddAngularImpulseInDegrees, (FVector, FName, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddAngularImpulseInRadians, (FVector, FName, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddForce, (FVector, FName, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddForceAtLocation, (FVector, FVector, FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddForceAtLocationLocal, (FVector, FVector, FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddImpulse, (FVector, FName, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddImpulseAtLocation, (FVector, FVector, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddRadialForce, (FVector, float, float, ERadialImpulseFalloff, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddRadialImpulse, (FVector, float, float, ERadialImpulseFalloff, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddTorqueInDegrees, (FVector, FName , bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddTorqueInRadians, (FVector, FName , bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, AddVelocityChangeImpulseAtLocation, (FVector, FVector, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CanCharacterStepUp, (APawn*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, ClearMoveIgnoreActors, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, ClearMoveIgnoreComponents, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CopyArrayOfMoveIgnoreActors, (), ERASE_ARGUMENT_PACK(TArray<AActor*>)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CopyArrayOfMoveIgnoreComponents, (), ERASE_ARGUMENT_PACK(TArray<UPrimitiveComponent*>)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CreateAndSetMaterialInstanceDynamic, (int), ERASE_ARGUMENT_PACK(UMaterialInstanceDynamic*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CreateAndSetMaterialInstanceDynamicFromMaterial, (int, UMaterialInterface*), ERASE_ARGUMENT_PACK(UMaterialInstanceDynamic*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, CreateDynamicMaterialInstance, (int, UMaterialInterface* , FName ), ERASE_ARGUMENT_PACK(UMaterialInstanceDynamic*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetAngularDamping, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetBodyInstanceAsyncPhysicsTickHandle, (FName , bool, int), ERASE_ARGUMENT_PACK(FBodyInstanceAsyncPhysicsTickHandle)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCenterOfMass, (FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetClosestPointOnCollision, (const FVector&, FVector&, FName ), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCollisionEnabled, (), ERASE_ARGUMENT_PACK(ECollisionEnabled)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCollisionObjectType, (), ERASE_ARGUMENT_PACK(ECollisionChannel)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCollisionProfileName, (), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCollisionResponseToChannel, (ECollisionChannel), ERASE_ARGUMENT_PACK(ECollisionResponse)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCustomPrimitiveDataIndexForScalarParameter, (FName), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCustomPrimitiveDataIndexForVectorParameter, (FName), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetGenerateOverlapEvents, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetIgnoreBoundsForEditorFocus, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetInertiaTensor, (FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetLinearDamping, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMass, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMassScale, (FName ), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaterial, (int), ERASE_ARGUMENT_PACK(UMaterialInterface*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaterialByName, (FName), ERASE_ARGUMENT_PACK(UMaterialInterface*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaterialFromCollisionFaceIndex, (int, int&), ERASE_ARGUMENT_PACK(UMaterialInterface*)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaterialIndex, (FName), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaterialSlotNames, (), ERASE_ARGUMENT_PACK(TArray<FName>)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetMaxDepenetrationVelocity, (FName ), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetNumMaterials, (), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetOverlappingActors, (TArray<AActor*>&, TSubclassOf<AActor> ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetOverlappingComponents, (TArray<UPrimitiveComponent*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetPhysicsAngularVelocityInDegrees, (FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetPhysicsAngularVelocityInRadians, (FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetPhysicsLinearVelocity, (FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetPhysicsLinearVelocityAtPoint, (FVector, FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetStaticWhenNotMoveable, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetUpdateKinematicFromSimulation, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetWalkableSlopeOverride, (), ERASE_ARGUMENT_PACK(const FWalkableSlopeOverride&)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IgnoreActorWhenMoving, (AActor*, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IgnoreComponentWhenMoving, (UPrimitiveComponent*, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, InvalidateLumenSurfaceCache, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsAnyRigidBodyAwake, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsExcludedFromHLODLevel, (EHLODLevelExclusion), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsGravityEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsMaterialSlotNameValid, (FName), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsOverlappingActor, (const AActor*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsOverlappingComponent, (const UPrimitiveComponent*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, BoxOverlapComponent, (FVector, const FBox, bool, bool, bool, FVector&, FVector&, FName&, FHitResult&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsCollisionEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsPhysicsCollisionEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, IsQueryCollisionEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, LineTraceComponent, (FVector, FVector, bool, bool, bool, FVector&, FVector&, FName&, FHitResult&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SphereOverlapComponent, (FVector, float, bool, bool, bool, FVector&, FVector&, FName&, FHitResult&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SphereTraceComponent, (FVector, FVector, float, bool, bool, bool, FVector&, FVector&, FName&, FHitResult&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, PutRigidBodyToSleep, (FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, ScaleByMomentOfInertia, (FVector, FName ), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAffectDistanceFieldLighting, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAffectDynamicIndirectLighting, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAffectIndirectLightingWhileHidden, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAllMassScale, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAllPhysicsAngularVelocityInDegrees, (const FVector&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAllPhysicsAngularVelocityInRadians, (const FVector&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAllPhysicsLinearVelocity, (FVector, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAllUseCCD, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetAngularDamping, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetBoundsScale, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCastContactShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCastHiddenShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCastInsetShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCastShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCenterOfMass, (FVector, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCollisionEnabled, (ECollisionEnabled), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCollisionObjectType, (ECollisionChannel), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCollisionProfileName, (FName, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCollisionResponseToAllChannels, (ECollisionResponse), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCollisionResponseToChannel, (ECollisionChannel, ECollisionResponse), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetConstraintMode, (EDOFMode), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCullDistance, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomDepthStencilValue, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomDepthStencilWriteMask, (ERendererStencilMask), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomPrimitiveDataFloat, (int, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomPrimitiveDataVector2, (int, FVector2D), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomPrimitiveDataVector3, (int, FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetCustomPrimitiveDataVector4, (int, FVector4), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetDefaultCustomPrimitiveDataFloat, (int, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetDefaultCustomPrimitiveDataVector2, (int, FVector2D), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetDefaultCustomPrimitiveDataVector3, (int, FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetDefaultCustomPrimitiveDataVector4, (int, FVector4), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetEmissiveLightSource, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetEnableGravity, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetExcludedFromHLODLevel, (EHLODLevelExclusion, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetExcludeFromLightAttachmentGroup, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetGenerateOverlapEvents, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetHiddenInSceneCapture, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetHoldout, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetIgnoreBoundsForEditorFocus, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetLightAttachmentsAsGroup, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetLightingChannels, (bool, bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetLinearDamping, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetMassOverrideInKg, (FName , float, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetMassScale, (FName , float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetMaterial, (int, UMaterialInterface*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetMaterialByName, (FName, UMaterialInterface*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetMaxDepenetrationVelocity, (FName , float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetNotifyRigidBodyCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetOnlyOwnerSee, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetOwnerNoSee, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysicsAngularVelocityInDegrees, (FVector, bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysicsAngularVelocityInRadians, (FVector, bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysicsLinearVelocity, (FVector, bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysicsMaxAngularVelocityInDegrees, (float, bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysicsMaxAngularVelocityInRadians, (float, bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetPhysMaterialOverride, (UPhysicalMaterial*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetReceivesDecals, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetRenderCustomDepth, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetRenderInDepthPass, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetRenderInMainPass, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetScalarParameterForCustomPrimitiveData, (FName, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetScalarParameterForDefaultCustomPrimitiveData, (FName, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetSimulatePhysics, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetSingleSampleShadowFromStationaryLights, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetStaticWhenNotMoveable, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetTranslucencySortDistanceOffset, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetTranslucentSortPriority, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetUpdateKinematicFromSimulation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetUseCCD, (bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetVectorParameterForCustomPrimitiveData, (FName, FVector4), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetVectorParameterForDefaultCustomPrimitiveData, (FName, FVector4), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetVisibleInRayTracing, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetVisibleInSceneCaptureOnly, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetWalkableSlopeOverride, (const FWalkableSlopeOverride&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, WakeAllRigidBodies, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, WakeRigidBody, (FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, WasRecentlyRendered, (float), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbGenerateOverlapEvents, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbGenerateOverlapEvents, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetLightmapType, (), ERASE_ARGUMENT_PACK(const ELightmapType&)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbEnableAutoLODGeneration, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbEnableAutoLODGeneration, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbNeverDistanceCull, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbNeverDistanceCull, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbAlwaysCreatePhysicsState, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbAlwaysCreatePhysicsState, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbMultiBodyOverlap, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbMultiBodyOverlap, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbTraceComplexOnMove, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbTraceComplexOnMove, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbReturnMaterialOnMove, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbReturnMaterialOnMove, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbAllowCullDistanceVolume, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbAllowCullDistanceVolume, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbVisibleInReflectionCaptures, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbVisibleInReflectionCaptures, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbVisibleInRealTimeSkyCaptures, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbVisibleInRealTimeSkyCaptures, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbVisibleInRayTracing, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbVisibleInRayTracing, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbRenderInMainPass, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbRenderInMainPass, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbRenderInDepthPass, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbRenderInDepthPass, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbReceivesDecals, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbReceivesDecals, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbHoldout, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbHoldout, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbOwnerNoSee, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbOwnerNoSee, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbOnlyOwnerSee, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbOnlyOwnerSee, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbTreatAsBackgroundForOcclusion, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbTreatAsBackgroundForOcclusion, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbUseAsOccluder, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbUseAsOccluder, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbConsiderForActorPlacementWhenHidden, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbForceMipStreaming, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbForceMipStreaming, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCastShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbEmissiveLightSource, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbEmissiveLightSource, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbAffectDynamicIndirectLighting, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbAffectDynamicIndirectLighting, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbAffectIndirectLightingWhileHidden, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbAffectIndirectLightingWhileHidden, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbAffectDistanceFieldLighting, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbAffectDistanceFieldLighting, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastDynamicShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastDynamicShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastStaticShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastStaticShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastVolumetricTranslucentShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastVolumetricTranslucentShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastContactShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastContactShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbSelfShadowOnly, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbSelfShadowOnly, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastFarShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastFarShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastInsetShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastInsetShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastCinematicShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastCinematicShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastHiddenShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastHiddenShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbCastShadowAsTwoSided, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbCastShadowAsTwoSided, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbLightAttachmentsAsGroup, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbLightAttachmentsAsGroup, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbExcludeFromLightAttachmentGroup, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbExcludeFromLightAttachmentGroup, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbReceiveMobileCSMShadows, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbReceiveMobileCSMShadows, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbSingleSampleShadowFromStationaryLights, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbSingleSampleShadowFromStationaryLights, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbIgnoreRadialImpulse, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbIgnoreRadialImpulse, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbIgnoreRadialForce, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbIgnoreRadialForce, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbApplyImpulseOnDamage, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbApplyImpulseOnDamage, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbReplicatePhysicsToAutonomousProxy, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbReplicatePhysicsToAutonomousProxy, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbFillCollisionUnderneathForNavmesh, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbRenderCustomDepth, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbRenderCustomDepth, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbVisibleInSceneCaptureOnly, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbVisibleInSceneCaptureOnly, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbHiddenInSceneCapture, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbHiddenInSceneCapture, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetbStaticWhenNotMoveable, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, SetbStaticWhenNotMoveable, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetLightingChannels, (), ERASE_ARGUMENT_PACK(const FLightingChannels&)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCustomDepthStencilValue, (), ERASE_ARGUMENT_PACK(const int&)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetTranslucencySortDistanceOffset, (), ERASE_ARGUMENT_PACK(const float&)) },
{ ERASE_METHOD_PTR(UPrimitiveComponent, GetCustomDepthStencilWriteMask, (), ERASE_ARGUMENT_PACK(const ERendererStencilMask&)) },


{ ERASE_METHOD_PTR(UMeshComponent, GetMaterials, (), ERASE_ARGUMENT_PACK(TArray<UMaterialInterface*>)) },
{ ERASE_METHOD_PTR(UMeshComponent, GetOverlayMaterial, (), ERASE_ARGUMENT_PACK(UMaterialInterface*)) },
{ ERASE_METHOD_PTR(UMeshComponent, GetOverlayMaterialMaxDrawDistance, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UMeshComponent, PrestreamMeshLODs, (float), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshComponent, PrestreamTextures, (float, bool, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshComponent, SetOverlayMaterial, (UMaterialInterface*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshComponent, SetOverlayMaterialMaxDrawDistance, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshComponent, SetScalarParameterValueOnMaterials, (const FName, const float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshComponent, SetVectorParameterValueOnMaterials, (const FName, const FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMeshComponent, GetbEnableMaterialParameterCaching, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMeshComponent, SetbEnableMaterialParameterCaching, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UWidgetComponent, GetCurrentDrawSize, (), ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetCylinderArcAngle, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetDrawAtDesiredSize, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetDrawSize, (), ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetGeometryMode, (), ERASE_ARGUMENT_PACK(EWidgetGeometryMode)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetManuallyRedraw, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetMaterialInstance, (), ERASE_ARGUMENT_PACK(UMaterialInstanceDynamic*)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetOwnerPlayer, (), ERASE_ARGUMENT_PACK(ULocalPlayer*)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetPivot, (), ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetRedrawTime, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetRenderTarget, (), ERASE_ARGUMENT_PACK(UTextureRenderTarget2D*)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetTickWhenOffscreen, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetTwoSided, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetUserWidgetObject, (), ERASE_ARGUMENT_PACK(UUserWidget*)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetWidget, (), ERASE_ARGUMENT_PACK(UUserWidget*)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetWidgetSpace, (), ERASE_ARGUMENT_PACK(EWidgetSpace)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetWindowFocusable, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, GetWindowVisiblility, (), ERASE_ARGUMENT_PACK(EWindowVisibility)) },
{ ERASE_METHOD_PTR(UWidgetComponent, IsWidgetVisible, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UWidgetComponent, RequestRedraw, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, RequestRenderUpdate, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetBackgroundColor, (const FLinearColor), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetCylinderArcAngle, (const float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetDrawAtDesiredSize, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetDrawSize, (FVector2D), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetGeometryMode, (EWidgetGeometryMode), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetManuallyRedraw, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetOwnerPlayer, (ULocalPlayer*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetPivot, (const FVector2D&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetRedrawTime, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetTickMode, (ETickMode), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetTickWhenOffscreen, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetTintColorAndOpacity, (const FLinearColor), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetTwoSided, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetWidget, (UUserWidget*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetWidgetSpace, (EWidgetSpace), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetWindowFocusable, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UWidgetComponent, SetWindowVisibility, (EWindowVisibility), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UViewportInteractor, CanCarry, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetDraggingMode, (), ERASE_ARGUMENT_PACK(EViewportInteractionDraggingMode)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetHitResultGizmoFilterMode, (), ERASE_ARGUMENT_PACK(EHitResultGizmoFilterMode)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetHoverLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetLaserPointer, (FVector&, FVector&, const bool, const float), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetLastRoomSpaceTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetLastTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetOtherInteractor, (), ERASE_ARGUMENT_PACK(UViewportInteractor*)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetRoomSpaceTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetTransformAndForwardVector, (FTransform&, FVector&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UViewportInteractor, GetWorldInteraction, (), ERASE_ARGUMENT_PACK(UViewportWorldInteraction*)) },
{ ERASE_METHOD_PTR(UViewportInteractor, HandleInputAxis_BP, (const FViewportActionKeyInput&, const FKey, const float, const float, bool&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, HandleInputKey_BP, (const FViewportActionKeyInput&, const FKey, const EInputEvent, bool&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, IsHoveringOverGizmo, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UViewportInteractor, SetCanCarry, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, SetDraggingMode, (const EViewportInteractionDraggingMode), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, SetHitResultGizmoFilterMode, (EHitResultGizmoFilterMode), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, Shutdown, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportInteractor, Tick, (const float), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UVREditorInteractor, GetControllerHandSide, (), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetControllerSide, (), ERASE_ARGUMENT_PACK(EControllerHand)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetControllerType, (), ERASE_ARGUMENT_PACK(EControllerType)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetHMDDeviceType, (), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetLaserEnd, (), ERASE_ARGUMENT_PACK(const FVector&)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetLaserStart, (), ERASE_ARGUMENT_PACK(const FVector&)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetLastTrackpadPosition, (), ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetMotionControllerComponent, (), ERASE_ARGUMENT_PACK(UMotionControllerComponent*)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetSelectAndMoveTriggerValue, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetSlideDelta, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetTeleportActor, (), ERASE_ARGUMENT_PACK(AVREditorTeleporter*)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, GetTrackpadPosition, (), ERASE_ARGUMENT_PACK(FVector2D)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, Init, (UVREditorMode*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, IsClickingOnUI, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, IsHoveringOverUI, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, IsTouchingTrackpad, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, ReplaceHandMeshComponent, (UStaticMesh*, FVector, ERASE_ARGUMENT_PACK(void))) },
{ ERASE_METHOD_PTR(UVREditorInteractor, SetControllerHandSide, (const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, SetControllerType, (const EControllerType), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, SetForceLaserColor, (const FLinearColor&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, SetForceShowLaser, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, SetupComponent, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, TryOverrideControllerType, (const EControllerType), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVREditorInteractor, UpdateHandMeshRelativeTransform, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UVREditorMode, GetWorldScaleFactor, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UVREditorMode, IsInGameView, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVREditorMode, SetGameView, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(AVREditorTeleporter, DoTeleport, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, GetInteractorTryingTeleport, (), ERASE_ARGUMENT_PACK(UViewportInteractor*)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, GetSlideDelta, (UVREditorInteractor*, const bool), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, GetVRMode, (), ERASE_ARGUMENT_PACK(UVREditorMode*)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, Init, (UVREditorMode*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, IsAiming, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, IsTeleporting, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, SetColor, (const FLinearColor&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, SetVisibility, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, Shutdown, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, StartAiming, (UViewportInteractor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, StartTeleport, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, StopAiming, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AVREditorTeleporter, TeleportDone, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UVISettings, SetbScaleWorldFromFloor, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVISettings, SetbScaleWorldWithDynamicPivot, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVISettings, SetbAllowSimultaneousWorldScalingAndRotation, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UVRModeSettings, SetbEnableAutoVREditMode, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRModeSettings, SetbAutokeySequences, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRModeSettings, SetbShowWorldMovementGrid, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRModeSettings, SetbShowWorldMovementPostProcess, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRModeSettings, SetbShowWorldScaleProgressBar, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UVRScoutingInteractor, GetGizmoMode, (), ERASE_ARGUMENT_PACK(EGizmoHandleTypes)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, GetInputComponent, (), ERASE_ARGUMENT_PACK(UInputComponent*)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, GetReceivesEditorInput, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, SetGizmoMode, (EGizmoHandleTypes), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, SetReceivesEditorInput, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, GetbReceivesEditorInput, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UVRScoutingInteractor, SetbReceivesEditorInput, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UFactory, ScriptFactoryCanImport, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, ScriptFactoryCreateFile, (UAssetImportTask*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, GetbCreateNew, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, SetbCreateNew, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFactory, GetbEditAfterNew, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, SetbEditAfterNew, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFactory, GetbEditorImport, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, SetbEditorImport, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFactory, GetbText, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UFactory, SetbText, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UMotionControllerComponent, GetAngularVelocity, (FRotator&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetHandJointPosition, (int, bool&), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetLinearAcceleration, (FVector&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetLinearVelocity, (FVector&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetParameterValue, (FName, bool&), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetTrackingSource, (), ERASE_ARGUMENT_PACK(EControllerHand)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, IsTracked, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, OnMotionControllerUpdated, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetAssociatedPlayerIndex, (const int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetTrackingMotionSource, (const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetTrackingSource, (const EControllerHand), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetPlayerIndex, (const int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetMotionSource, (const FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetPlayerIndex, (), ERASE_ARGUMENT_PACK(const int&)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetMotionSource, (), ERASE_ARGUMENT_PACK(const FName&)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, GetbDisableLowLatencyUpdate, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UMotionControllerComponent, SetbDisableLowLatencyUpdate, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UViewportWorldInteraction, AddActorToExcludeFromHitTests, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, AddInteractor, (UViewportInteractor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetHeadTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetInteractors, (), ERASE_ARGUMENT_PACK(const TArray<UViewportInteractor*>&)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetRoomSpaceHeadTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetRoomTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetTransformGizmoActor, (), ERASE_ARGUMENT_PACK(ABaseTransformGizmo*)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, GetWorldScaleFactor, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, RemoveInteractor, (UViewportInteractor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, SetHeadTransform, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, SetRoomTransformForNextFrame, (const FTransform&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UViewportWorldInteraction, SetWorldToMetersScale, (const float, const bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UStaticMeshComponent, GetInitialEvaluateWorldPositionOffset, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetLocalBounds, (FVector&, FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetDistanceFieldSelfShadowBias, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetEvaluateWorldPositionOffset, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetEvaluateWorldPositionOffsetInRayTracing, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetForceDisableNanite, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetForcedLodModel, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetReverseCulling, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetStaticMesh, (UStaticMesh*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetWorldPositionOffsetDisableDistance, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, UpdateInitialEvaluateWorldPositionOffset, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetForcedLodModel, (), ERASE_ARGUMENT_PACK(const int&)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetStaticMesh, (), ERASE_ARGUMENT_PACK(UStaticMesh*)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbForceNaniteForMasked, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbForceNaniteForMasked, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbDisallowNanite, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbDisallowNanite, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbEvaluateWorldPositionOffset, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbEvaluateWorldPositionOffset, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbWorldPositionOffsetWritesVelocity, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbWorldPositionOffsetWritesVelocity, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbEvaluateWorldPositionOffsetInRayTracing, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbEvaluateWorldPositionOffsetInRayTracing, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetWorldPositionOffsetDisableDistance, (), ERASE_ARGUMENT_PACK(const int&)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbOverrideWireframeColor, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbOverrideWireframeColor, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbOverrideMinLOD, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbOverrideMinLOD, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbDisallowMeshPaintPerInstance, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbDisallowMeshPaintPerInstance, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbIgnoreInstanceForTextureStreaming, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbIgnoreInstanceForTextureStreaming, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbOverrideLightMapRes, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbOverrideLightMapRes, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbCastDistanceFieldIndirectShadow, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbCastDistanceFieldIndirectShadow, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbOverrideDistanceFieldSelfShadowBias, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbOverrideDistanceFieldSelfShadowBias, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbUseDefaultCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbSortTriangles, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbSortTriangles, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetbReverseCulling, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, SetbReverseCulling, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UStaticMeshComponent, GetDistanceFieldSelfShadowBias, (), ERASE_ARGUMENT_PACK(const float&)) },


{ ERASE_METHOD_PTR(ULevelEditorContextMenuContext, GetHitProxyElement, (), ERASE_ARGUMENT_PACK(FScriptTypedElementHandle)) },


{ ERASE_METHOD_PTR(ULevelEditorSubsystem, BuildLightMaps, (ELightingBuildQuality, bool), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EditorGetGameView, (FName ), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EditorInvalidateViewports, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EditorPlaySimulate, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EditorRequestEndPlay, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EditorSetGameView, (bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, EjectPilotLevelActor, (FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetActiveViewportConfigKey, (), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetAllowsCinematicControl, (FName ), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetCurrentLevel, (), ERASE_ARGUMENT_PACK(ULevel*)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetPilotLevelActor, (FName ), ERASE_ARGUMENT_PACK(AActor*)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetSelectionSet, (), ERASE_ARGUMENT_PACK(UTypedElementSelectionSet*)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, GetViewportConfigKeys, (), ERASE_ARGUMENT_PACK(TArray<FName>)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, IsInPlayInEditor, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, LoadLevel, (const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, NewLevel, (const FString&, bool), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, NewLevelFromTemplate, (const FString&, const FString&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, PilotLevelActor, (AActor*, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, SaveAllDirtyLevels, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, SaveCurrentLevel, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, SetAllowsCinematicControl, (bool, FName ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ULevelEditorSubsystem, SetCurrentLevelByName, (FName), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UGameplayTask, EndTask, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UGameplayTaskResource, SetbManuallySetID, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UGameplayDebuggerUserSettings, SetbEnableGameplayDebuggerInEditor, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAISenseConfig, GetbStartsEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAISenseConfig, SetbStartsEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAISenseConfig_Hearing, SetbUseLoSHearing, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, Finish, (EPawnActionResult), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, GetActionPriority, (), ERASE_ARGUMENT_PACK(EAIRequestPriority)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, GetbAllowNewSameClassInstance, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, SetbAllowNewSameClassInstance, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, GetbReplaceActiveSameClassInstance, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, SetbReplaceActiveSameClassInstance, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, GetbShouldPauseMovement, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, SetbShouldPauseMovement, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, GetbAlwaysNotifyOnFinished, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction, SetbAlwaysNotifyOnFinished, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UDEPRECATED_PawnActionsComponent, AbortAction, (UDEPRECATED_PawnAction*), ERASE_ARGUMENT_PACK(EPawnActionAbortState)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnActionsComponent, ForceAbortAction, (UDEPRECATED_PawnAction*), ERASE_ARGUMENT_PACK(EPawnActionAbortState)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnActionsComponent, PushAction, (UDEPRECATED_PawnAction*, EAIRequestPriority, UObject* ), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_BlueprintBase, ActionFinished, (APawn*, EPawnActionResult), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_BlueprintBase, ActionPause, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_BlueprintBase, ActionResume, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_BlueprintBase, ActionStart, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_BlueprintBase, ActionTick, (APawn*, float), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_Move, GetbAllowStrafe, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UDEPRECATED_PawnAction_Move, SetbAllowStrafe, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(AController, ClientSetLocation, (FVector, FRotator), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ClientSetRotation, (FRotator, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, GetControlRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(AController, GetDesiredRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(AController, GetPlayerViewPoint, (FVector&, FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, GetViewTarget, (), ERASE_ARGUMENT_PACK(AActor*)) },
{ ERASE_METHOD_PTR(AController, IsLocalController, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AController, IsLocalPlayerController, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AController, IsLookInputIgnored, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AController, IsMoveInputIgnored, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AController, IsPlayerController, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AController, GetControlledPawn, (), ERASE_ARGUMENT_PACK(APawn*)) },
{ ERASE_METHOD_PTR(AController, LineOfSightTo, (const AActor*, FVector, ERASE_ARGUMENT_PACK(bool))) },
{ ERASE_METHOD_PTR(AController, Possess, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, InstigatedAnyDamage, (float, const UDamageType*, AActor*, AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ReceivePossess, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ReceiveUnPossess, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ResetIgnoreInputFlags, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ResetIgnoreLookInput, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, ResetIgnoreMoveInput, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, SetControlRotation, (const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, SetIgnoreLookInput, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, SetIgnoreMoveInput, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, SetInitialLocationAndRotation, (const FVector&, const FRotator&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, StopMovement, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, UnPossess, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AController, SetbAttachToPawn, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(AAIController, ClaimTaskResource, (TSubclassOf<UGameplayTaskResource>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetAIPerceptionComponent, (), ERASE_ARGUMENT_PACK(UAIPerceptionComponent*)) },
{ ERASE_METHOD_PTR(AAIController, GetDeprecatedActionsComponent, (), ERASE_ARGUMENT_PACK(UDEPRECATED_PawnActionsComponent*)) },
{ ERASE_METHOD_PTR(AAIController, GetFocalPoint, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(AAIController, GetFocalPointOnActor, (const AActor*), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(AAIController, GetFocusActor, (), ERASE_ARGUMENT_PACK(AActor*)) },
{ ERASE_METHOD_PTR(AAIController, GetImmediateMoveDestination, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(AAIController, GetMoveStatus, (), ERASE_ARGUMENT_PACK(EPathFollowingStatus)) },
{ ERASE_METHOD_PTR(AAIController, GetPathFollowingComponent, (), ERASE_ARGUMENT_PACK(UPathFollowingComponent*)) },
{ ERASE_METHOD_PTR(AAIController, HasPartialPath, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, ClearFocus, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, SetFocalPoint, (FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, SetFocus, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, MoveToActor, (AActor*, float, bool, bool, bool, TSubclassOf<UNavigationQueryFilter> , bool), ERASE_ARGUMENT_PACK(EPathFollowingRequestResult)) },
{ ERASE_METHOD_PTR(AAIController, MoveToLocation, (const FVector&, float, bool, bool, bool, bool, TSubclassOf<UNavigationQueryFilter>, bool), ERASE_ARGUMENT_PACK(EPathFollowingRequestResult)) },
{ ERASE_METHOD_PTR(AAIController, OnUsingBlackBoard, (UBlackboardComponent*, UBlackboardData*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, RunBehaviorTree, (UBehaviorTree*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetMoveBlockDetection, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, SetPathFollowingComponent, (UPathFollowingComponent*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, UnclaimTaskResource, (TSubclassOf<UGameplayTaskResource>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, UseBlackboard, (UBlackboardData*, UBlackboardComponent*&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, GetActionsComp, (), ERASE_ARGUMENT_PACK(UDEPRECATED_PawnActionsComponent*)) },
{ ERASE_METHOD_PTR(AAIController, GetbStartAILogicOnPossess, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbStartAILogicOnPossess, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetbStopAILogicOnUnposses, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbStopAILogicOnUnposses, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetbSkipExtraLOSChecks, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbSkipExtraLOSChecks, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetbAllowStrafe, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbAllowStrafe, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetbWantsPlayerState, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbWantsPlayerState, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, GetbSetControlRotationFromPawnOrientation, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(AAIController, SetbSetControlRotationFromPawnOrientation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AAIController, SetActionsComp, (UDEPRECATED_PawnActionsComponent*), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBrainComponent, IsPaused, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBrainComponent, IsRunning, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBrainComponent, RestartLogic, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBrainComponent, StartLogic, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBrainComponent, StopLogic, (const FString&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBehaviorTreeComponent, AddCooldownTagDuration, (FGameplayTag, float, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBehaviorTreeComponent, GetTagCooldownEndTime, (FGameplayTag), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UBehaviorTreeComponent, SetDynamicSubtree, (FGameplayTag, UBehaviorTree*), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBlackboardComponent, ClearValue, (const FName&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetLocationFromEntry, (const FName&, FVector&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetRotationFromEntry, (const FName&, FRotator&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsBool, (const FName&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsClass, (const FName&), ERASE_ARGUMENT_PACK(UClass*)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsEnum, (const FName&), ERASE_ARGUMENT_PACK(uint328)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsFloat, (const FName&), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsInt, (const FName&), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsName, (const FName&), ERASE_ARGUMENT_PACK(FName)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsObject, (const FName&), ERASE_ARGUMENT_PACK(UObject*)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsRotator, (const FName&), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsString, (const FName&), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, GetValueAsVector, (const FName&), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, IsVectorValueSet, (const FName&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsBool, (const FName&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsClass, (const FName&, UClass*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsEnum, (const FName&, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsFloat, (const FName&, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsInt, (const FName&, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsName, (const FName&, FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsObject, (const FName&, UObject*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsRotator, (const FName&, FRotator), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsString, (const FName&, FString), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBlackboardComponent, SetValueAsVector, (const FName&, FVector), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTCompositeNode, SetbApplyDecoratorScope, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTDecorator, SetbInverseCondition, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTService, SetbCallTickOnSearchStart, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService, SetbRestartTimerOnEachActivation, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTTaskNode, SetbIgnoreRestartSelf, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, IsDecoratorExecutionActive, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, IsDecoratorObserverActive, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, PerformConditionCheck, (AActor*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, PerformConditionCheckAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ExecutionFinish, (AActor*, EBTNodeResult), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ExecutionFinishAI, (AAIController*, APawn*, EBTNodeResult), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ExecutionStart, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ExecutionStartAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ObserverActivated, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ObserverActivatedAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ObserverDeactivated, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, ObserverDeactivatedAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, Tick, (AActor*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, TickAI, (AAIController*, APawn*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, SetbShowPropertyDetails, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_BlueprintBase, SetbCheckConditionOnlyBlackBoardChanges, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTDecorator_IsAtLocation, SetbUseNavAgentGoalLocation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTDecorator_IsAtLocation, SetbPathFindingBasedTest, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTService_BlueprintBase, IsServiceActive, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, Activation, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, ActivationAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, Deactivation, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, DeactivationAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, SearchStart, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, SearchStartAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, Tick, (AActor*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, TickAI, (AAIController*, APawn*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, SetbShowPropertyDetails, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTService_BlueprintBase, SetbShowEventDetails, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, FinishAbort, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, FinishExecute, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, IsTaskAborting, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, IsTaskExecuting, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, Abort, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, AbortAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, Execute, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, ExecuteAI, (AAIController*, APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, Tick, (AActor*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, TickAI, (AAIController*, APawn*, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, SetFinishOnMessage, (FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, SetFinishOnMessageWithId, (FName, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_BlueprintBase, SetbShowPropertyDetails, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTTask_GameplayTaskBase, SetbWaitForGameplayTask, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbObserveBlackboardValue, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbAllowStrafe, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbAllowPartialPath, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbTrackMovingGoal, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbRequireNavigableEndLocation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbProjectGoalLocation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbReachTestIncludesAgentRadius, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_MoveTo, SetbReachTestIncludesGoalRadius, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UBTTask_PlayAnimation, SetbLooping, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UBTTask_PlayAnimation, SetbNonBlocking, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAIDataProvider_Random, SetbInteger, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryContext_BlueprintBase, ProvideActorsSet, (UObject*, AActor*, TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryContext_BlueprintBase, ProvideLocationsSet, (UObject*, AActor*, TArray<FVector>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryContext_BlueprintBase, ProvideSingleActor, (UObject*, AActor*, AActor&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryContext_BlueprintBase, ProvideSingleLocation, (UObject*, AActor*, FVector&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator, SetbAutoSortTests, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, GetItemScore, (int), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, GetQueryResultsAsActors, (TArray<AActor*>&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, GetQueryResultsAsLocations, (TArray<FVector>&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, GetResultsAsActors, (), ERASE_ARGUMENT_PACK(TArray<AActor*>)) },
{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, GetResultsAsLocations, (), ERASE_ARGUMENT_PACK(TArray<FVector>)) },
{ ERASE_METHOD_PTR(UEnvQueryInstanceBlueprintWrapper, SetNamedParam, (FName, float), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(APawn, AddControllerPitchInput, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, AddControllerRollInput, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, AddControllerYawInput, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, AddMovementInput, (FVector, float, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, ConsumeMovementInputVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(APawn, DetachFromControllerPendingDestroy, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, GetBaseAimRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(APawn, GetController, (), ERASE_ARGUMENT_PACK(AController*)) },
{ ERASE_METHOD_PTR(APawn, GetControlRotation, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(APawn, GetLastMovementInputVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(APawn, GetLocalViewingPlayerController, (), ERASE_ARGUMENT_PACK(APlayerController*)) },
{ ERASE_METHOD_PTR(APawn, GetMovementComponent, (), ERASE_ARGUMENT_PACK(UPawnMovementComponent*)) },
{ ERASE_METHOD_PTR(APawn, GetNavAgentLocation, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(APawn, GetOverrideInputComponentClass, (), ERASE_ARGUMENT_PACK(TSubclassOf<UInputComponent>)) },
{ ERASE_METHOD_PTR(APawn, GetPendingMovementInputVector, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(APawn, GetPlatformUserId, (), ERASE_ARGUMENT_PACK(FPlatformUserId)) },
{ ERASE_METHOD_PTR(APawn, IsBotControlled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsControlled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsLocallyControlled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsLocallyViewed, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsMoveInputIgnored, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsPawnControlled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, IsPlayerControlled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, PawnMakeNoise, (float, FVector, bool, AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, ControllerChanged, (AController*, AController*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, Possessed, (AController*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, Restarted, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, Unpossessed, (AController*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, SetCanAffectNavigationGeneration, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, SpawnDefaultController, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, GetbUseControllerRotationPitch, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, SetbUseControllerRotationPitch, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, GetbUseControllerRotationYaw, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, SetbUseControllerRotationYaw, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, GetbUseControllerRotationRoll, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, SetbUseControllerRotationRoll, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, GetbCanAffectNavigationGeneration, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(APawn, SetbCanAffectNavigationGeneration, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(APawn, SetOverrideInputComponentClass, (const TSubclassOf<UInputComponent>&), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(ACharacter, CacheInitialMeshOffset, (FVector, FRotator), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, CanCrouch, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, CanJump, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, CanJumpInternal, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, ClientAckGoodMove, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientAdjustPosition, (float, FVector, FVector, UPrimitiveComponent*, FName, bool, bool, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientAdjustRootMotionPosition, (float, float, FVector, FVector, float, UPrimitiveComponent*, FName, bool, bool, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientCheatFly, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientCheatGhost, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientCheatWalk, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ClientVeryShortAdjustPosition, (float, FVector, UPrimitiveComponent*, FName, bool, bool, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, Crouch, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, GetAnimRootMotionTranslationScale, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(ACharacter, GetBaseRotationOffset, (), ERASE_ARGUMENT_PACK(FRotator)) },
{ ERASE_METHOD_PTR(ACharacter, GetBaseTranslationOffset, (), ERASE_ARGUMENT_PACK(FVector)) },
{ ERASE_METHOD_PTR(ACharacter, GetCurrentMontage, (), ERASE_ARGUMENT_PACK(UAnimMontage*)) },
{ ERASE_METHOD_PTR(ACharacter, HasAnyRootMotion, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, IsJumpProvidingForce, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, IsPlayingNetworkedRootMotionMontage, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, IsPlayingRootMotion, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, Jump, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnEndCrouch, (float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnMovementModeChanged, (EMovementMode, EMovementMode, uint8, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnStartCrouch, (float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, UpdateCustomMovement, (float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, LaunchCharacter, (FVector, bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnJumped, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnLanded, (const FHitResult&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnLaunched, (FVector, bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, OnWalkingOffLedge, (const FVector&, const FVector&, const FVector&, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, PlayAnimMontage, (UAnimMontage*, float, FName ), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(ACharacter, RootMotionDebugClientPrintOnScreen, (const FString&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMove, (float, FVector, FVector, uint8, uint8, uint, UPrimitiveComponent*, FName, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMoveDual, (float, FVector, uint8, uint, float, FVector, FVector, uint8, uint8, uint, UPrimitiveComponent*, FName, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMoveDualHybridRootMotion, (float, FVector, uint8, uint, float, FVector, FVector, uint8, uint8, uint, UPrimitiveComponent*, FName, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMoveDualNoBase, (float, FVector, uint8, uint, float, FVector, FVector, uint8, uint8, uint, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMoveNoBase, (float, FVector, FVector, uint8, uint8, uint, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, ServerMoveOld, (float, FVector, uint8), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, StopAnimMontage, (UAnimMontage* ), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, StopJumping, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, UnCrouch, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ACharacter, GetbIsCrouched, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, GetbPressedJump, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ACharacter, GetbWasJumping, (), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(AEQSTestingPawn, SetbDrawLabels, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AEQSTestingPawn, SetbDrawFailedItems, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AEQSTestingPawn, SetbReRunQueryOnlyOnFinishedMove, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AEQSTestingPawn, SetbShouldBeVisibleInGame, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AEQSTestingPawn, SetbTickDuringGame, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator_BlueprintBase, AddGeneratedActor, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryGenerator_BlueprintBase, AddGeneratedVector, (FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryGenerator_BlueprintBase, DoItemGeneration, (const TArray<FVector>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryGenerator_BlueprintBase, DoItemGenerationFromActors, (const TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryGenerator_BlueprintBase, GetQuerier, (), ERASE_ARGUMENT_PACK(UObject*)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator_Composite, SetbAllowDifferentItemTypes, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator_Cone, SetbIncludeContextLocation, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator_Donut, SetbDefineArc, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryGenerator_OnCircle, SetbDefineArc, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UEnvQueryTest_Volume, SetbDoComplexVolumeTest, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UEnvQueryTest_Volume, SetbSkipTestIfNoVolumes, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UPathFollowingComponent, GetPathActionType, (), ERASE_ARGUMENT_PACK(EPathFollowingAction)) },
{ ERASE_METHOD_PTR(UPathFollowingComponent, GetPathDestination, (), ERASE_ARGUMENT_PACK(FVector)) },


{ ERASE_METHOD_PTR(UCrowdFollowingComponent, SuspendCrowdSteering, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UCrowdManager, SetbResolveCollisions, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(ANavLinkProxy, HasMovingAgents, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ANavLinkProxy, IsSmartLinkEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(ANavLinkProxy, SmartLinkReached, (AActor*, const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ANavLinkProxy, ResumePathFollowing, (AActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ANavLinkProxy, SetSmartLinkEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAIPerceptionComponent, ForgetAll, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, GetActorsPerception, (AActor*, FActorPerceptionBlueprintInfo&), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, GetCurrentlyPerceivedActors, (TSubclassOf<UAISense>, TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, GetKnownPerceivedActors, (TSubclassOf<UAISense>, TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, GetPerceivedHostileActors, (TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, GetPerceivedHostileActorsBySense, (const TSubclassOf<UAISense>, TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, IsSenseEnabled, (TSubclassOf<UAISense>), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, RequestStimuliListenerUpdate, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionComponent, SetSenseEnabled, (TSubclassOf<UAISense>, const bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, RegisterForSense, (TSubclassOf<UAISense>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, RegisterWithPerceptionSystem, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, UnregisterFromPerceptionSystem, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, UnregisterFromSense, (TSubclassOf<UAISense>), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, GetbAutoRegisterAsSource, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAIPerceptionStimuliSourceComponent, SetbAutoRegisterAsSource, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAIPerceptionSystem, ReportEvent, (UAISenseEvent*), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAISense, GetbWantsNewPawnNotification, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAISense, SetbWantsNewPawnNotification, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense, GetbAutoRegisterAllPawnsAsSources, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UAISense, SetbAutoRegisterAllPawnsAsSources, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UAISense_Blueprint, GetAllListenerActors, (TArray<AActor*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, GetAllListenerComponents, (TArray<UAIPerceptionComponent*>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, OnNewPawn, (APawn*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, OnListenerRegistered, (AActor*, UAIPerceptionComponent*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, OnListenerUnregistered, (AActor*, UAIPerceptionComponent*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, OnListenerUpdated, (AActor*, UAIPerceptionComponent*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UAISense_Blueprint, OnUpdate, (const TArray<UAISenseEvent*>&), ERASE_ARGUMENT_PACK(float)) },


{ ERASE_METHOD_PTR(UPawnSensingComponent, GetPeripheralVisionAngle, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetPeripheralVisionCosine, (), ERASE_ARGUMENT_PACK(float)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetPeripheralVisionAngle, (const float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetSensingInterval, (const float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetSensingUpdatesEnabled, (const bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetSensingInterval, (), ERASE_ARGUMENT_PACK(const float&)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetbEnableSensingUpdates, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetbEnableSensingUpdates, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetbOnlySensePlayers, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetbOnlySensePlayers, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetbSeePawns, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetbSeePawns, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, GetbHearNoises, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UPawnSensingComponent, SetbHearNoises, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(AChaosSolverActor, SetAsCurrentWorldSolver, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(AChaosSolverActor, SetSolverActive, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UFieldSystemComponent, AddFieldCommand, (bool, EFieldPhysicsType, UFieldSystemMetaData*, UFieldNodeBase*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, AddPersistentField, (bool, EFieldPhysicsType, UFieldSystemMetaData*, UFieldNodeBase*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyLinearForce, (bool, FVector, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyPhysicsField, (bool, EFieldPhysicsType, UFieldSystemMetaData*, UFieldNodeBase*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyRadialForce, (bool, FVector, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyRadialVectorFalloffForce, (bool, FVector, float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyStayDynamicField, (bool, FVector, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyStrainField, (bool, FVector, float, float, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ApplyUniformVectorFalloffForce, (bool, FVector, FVector, float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, RemovePersistentFields, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UFieldSystemComponent, ResetFieldSystem, (), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UFieldSystemMetaDataIteration, SetMetaDataIteration, (int), ERASE_ARGUMENT_PACK(UFieldSystemMetaDataIteration*)) },


{ ERASE_METHOD_PTR(UFieldSystemMetaDataProcessingResolution, SetMetaDataaProcessingResolutionType, (EFieldResolutionType), ERASE_ARGUMENT_PACK(UFieldSystemMetaDataProcessingResolution*)) },


{ ERASE_METHOD_PTR(UFieldSystemMetaDataFilter, SetMetaDataFilterType, (EFieldFilterType, EFieldObjectType, EFieldPositionType), ERASE_ARGUMENT_PACK(UFieldSystemMetaDataFilter*)) },


{ ERASE_METHOD_PTR(UUniformInteger, SetUniformInteger, (int), ERASE_ARGUMENT_PACK(UUniformInteger*)) },


{ ERASE_METHOD_PTR(URadialIntMask, SetRadialIntMask, (float, FVector, int, int, ESetMaskConditionType), ERASE_ARGUMENT_PACK(URadialIntMask*)) },


{ ERASE_METHOD_PTR(UUniformScalar, SetUniformScalar, (float), ERASE_ARGUMENT_PACK(UUniformScalar*)) },


{ ERASE_METHOD_PTR(UWaveScalar, SetWaveScalar, (float, FVector, float, float, float, EWaveFunctionType, EFieldFalloffType), ERASE_ARGUMENT_PACK(UWaveScalar*)) },


{ ERASE_METHOD_PTR(URadialFalloff, SetRadialFalloff, (float, float, float, float, float, FVector, EFieldFalloffType), ERASE_ARGUMENT_PACK(URadialFalloff*)) },


{ ERASE_METHOD_PTR(UPlaneFalloff, SetPlaneFalloff, (float, float, float, float, float, FVector, FVector, EFieldFalloffType), ERASE_ARGUMENT_PACK(UPlaneFalloff*)) },


{ ERASE_METHOD_PTR(UBoxFalloff, SetBoxFalloff, (float, float, float, float, FTransform, EFieldFalloffType), ERASE_ARGUMENT_PACK(UBoxFalloff*)) },


{ ERASE_METHOD_PTR(UNoiseField, SetNoiseField, (float, float, FTransform), ERASE_ARGUMENT_PACK(UNoiseField*)) },


{ ERASE_METHOD_PTR(UUniformVector, SetUniformVector, (float, FVector), ERASE_ARGUMENT_PACK(UUniformVector*)) },


{ ERASE_METHOD_PTR(URadialVector, SetRadialVector, (float, FVector), ERASE_ARGUMENT_PACK(URadialVector*)) },


{ ERASE_METHOD_PTR(URandomVector, SetRandomVector, (float), ERASE_ARGUMENT_PACK(URandomVector*)) },


{ ERASE_METHOD_PTR(UOperatorField, SetOperatorField, (float, const UFieldNodeBase*, const UFieldNodeBase*, EFieldOperationType), ERASE_ARGUMENT_PACK(UOperatorField*)) },


{ ERASE_METHOD_PTR(UToIntegerField, SetToIntegerField, (const UFieldNodeFloat*), ERASE_ARGUMENT_PACK(UToIntegerField*)) },


{ ERASE_METHOD_PTR(UToFloatField, SetToFloatField, (const UFieldNodeInt*), ERASE_ARGUMENT_PACK(UToFloatField*)) },


{ ERASE_METHOD_PTR(UCullingField, SetCullingField, (const UFieldNodeBase*, const UFieldNodeBase*, EFieldCullingOperationType), ERASE_ARGUMENT_PACK(UCullingField*)) },


{ ERASE_METHOD_PTR(UReturnResultsTerminal, SetReturnResultsTerminal, (), ERASE_ARGUMENT_PACK(UReturnResultsTerminal*)) },


{ ERASE_METHOD_PTR(UChaosDestructionListener, AddChaosSolverActor, (AChaosSolverActor), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, AddGeometryCollectionActor, (AGeometryCollectionActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, IsEventListening, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, RemoveChaosSolverActor, (AChaosSolverActor), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, RemoveGeometryCollectionActor, (AGeometryCollectionActor*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetBreakingEventEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetBreakingEventRequestSettings, (const FChaosBreakingEventRequestSettings&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetCollisionEventEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetCollisionEventRequestSettings, (const FChaosCollisionEventRequestSettings&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetRemovalEventEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetRemovalEventRequestSettings, (const FChaosRemovalEventRequestSettings&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetTrailingEventEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetTrailingEventRequestSettings, (const FChaosTrailingEventRequestSettings&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SortBreakingEvents, (TArray<FChaosBreakingEventData>&, EChaosBreakingSortMethod), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SortCollisionEvents, (TArray<FChaosCollisionEventData>&, EChaosCollisionSortMethod), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SortRemovalEvents, (TArray<FChaosRemovalEventData>&, EChaosRemovalSortMethod), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SortTrailingEvents, (TArray<FChaosTrailingEventData>&, EChaosTrailingSortMethod), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetbIsCollisionEventListeningEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetbIsCollisionEventListeningEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetbIsBreakingEventListeningEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetbIsBreakingEventListeningEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetbIsTrailingEventListeningEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetbIsTrailingEventListeningEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetbIsRemovalEventListeningEnabled, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, SetbIsRemovalEventListeningEnabled, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetCollisionEventRequestSettings, (), ERASE_ARGUMENT_PACK(const FChaosCollisionEventRequestSettings&)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetBreakingEventRequestSettings, (), ERASE_ARGUMENT_PACK(const FChaosBreakingEventRequestSettings&)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetTrailingEventRequestSettings, (), ERASE_ARGUMENT_PACK(const FChaosTrailingEventRequestSettings&)) },
{ ERASE_METHOD_PTR(UChaosDestructionListener, GetRemovalEventRequestSettings, (), ERASE_ARGUMENT_PACK(const FChaosRemovalEventRequestSettings&)) },


{ ERASE_METHOD_PTR(AGeometryCollectionActor, RaycastSingle, (FVector, FVector, FHitResult&), ERASE_ARGUMENT_PACK(bool)) },


{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyAngularVelocity, (int, const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyAssetDefaults, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyBreakingAngularVelocity, (int, const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyBreakingLinearVelocity, (int, const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyExternalStrain, (int, const FVector&, float, int, float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyInternalStrain, (int, const FVector&, float, int, float, float), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyKinematicField, (float, FVector), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyLinearVelocity, (int, const FVector&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, ApplyPhysicsField, (bool, EGeometryCollectionPhysicsTypeEnum, UFieldSystemMetaData*, UFieldNodeBase*), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, CrumbleActiveClusters, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, CrumbleCluster, (int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, EnableRootProxyForCustomRenderer, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetDebugInfo, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetInitialLevel, (int), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetInitialLocalRestTransforms, (), ERASE_ARGUMENT_PACK(TArray<FTransform>)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetLocalBounds, (), ERASE_ARGUMENT_PACK(FBox)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetMassAndExtents, (int, float&, FBox&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetRootCurrentTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetRootIndex, (), ERASE_ARGUMENT_PACK(int)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetRootInitialTransform, (), ERASE_ARGUMENT_PACK(FTransform)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, IsRootBroken, (), ERASE_ARGUMENT_PACK(bool)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, PhysicsCollision, (const FChaosPhysicsCollisionInfo&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, RemoveAllAnchors, (), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetAbandonedParticleCollisionProfileName, (FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetAnchoredByBox, (FBox, bool, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetAnchoredByIndex, (int, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetAnchoredByTransformedBox, (FBox, FTransform, bool, int), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetEnableDamageFromCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetLocalRestTransforms, (const TArray<FTransform>&, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyBreaks, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyCrumblings, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyGlobalBreaks, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyGlobalCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyGlobalCrumblings, (bool, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyGlobalRemovals, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetNotifyRemovals, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetPerLevelCollisionProfileNames, (const TArray<FName>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetPerParticleCollisionProfileName, (const TArray<int>&, FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetRestCollection, (const UGeometryCollection*, bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetbEnableDamageFromCollision, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetAbandonedCollisionProfileName, (FName), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, SetCollisionProfilePerLevel, (const TArray<FName>&), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetRestCollection, (), ERASE_ARGUMENT_PACK(const UGeometryCollection*)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetbEnableDamageFromCollision, (), ERASE_ARGUMENT_PACK(const bool&)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetAbandonedCollisionProfileName, (), ERASE_ARGUMENT_PACK(const FName&)) },
{ ERASE_METHOD_PTR(UGeometryCollectionComponent, GetCollisionProfilePerLevel, (), ERASE_ARGUMENT_PACK(const TArray<FName>&)) },


{ ERASE_METHOD_PTR(UGeometryCollection, SetConvertVertexColorsToSRGB, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollection, SetEnableNanite, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollection, SetbConvertVertexColorsToSRGB, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UGeometryCollection, GetEnableNanite, (), ERASE_ARGUMENT_PACK(const bool&)) },
{ ERASE_METHOD_PTR(UGeometryCollection, GetbConvertVertexColorsToSRGB, (), ERASE_ARGUMENT_PACK(const bool&)) },


{ ERASE_METHOD_PTR(ANavigationData, SetbEnableDrawing, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ANavigationData, SetbForceRebuildOnLoad, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ANavigationData, SetbAutoDestroyWhenNoNavigation, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(ANavigationData, SetbCanBeMainNavData, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UNavCollisionBase, SetbIsDynamicObstacle, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UNavCollision, SetbGatherConvexGeometry, (bool), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UNavCollision, SetbCreateOnClient, (bool), ERASE_ARGUMENT_PACK(void)) },


{ ERASE_METHOD_PTR(UNavigationPath, EnableDebugDrawing, (bool, FLinearColor, ERASE_ARGUMENT_PACK(void))) },
{ ERASE_METHOD_PTR(UNavigationPath, EnableRecalculationOnInvalidation, (ENavigationOptionFlag), ERASE_ARGUMENT_PACK(void)) },
{ ERASE_METHOD_PTR(UNavigationPath, GetDebugString, (), ERASE_ARGUMENT_PACK(FString)) },
{ ERASE_METHOD_PTR(UNavigationPath, GetPathCost, (), ERASE_ARGUMENT_PACK(float)) },

};
//*/